---
title: 三步写一个仿微信聊天放烟花
categories:
  - EasyGameFramework
  - 想法流水
tags:
  - EasyGameFramework
  - Discussion
  - enet
comments: false
date: 2021-01-17 21:29:02
img:
---
## 打个招呼

大家好~

**游戏开发之路有趣但不易,**

**玩起来才能一直热情洋溢。**

我是喜欢**玩游戏开发**的海潮

对就是玩😉

## 前言


最近微信更新了8.0版本，可以在聊天的时候放炸弹，烟花等动态表情。很多人都玩得不亦乐乎~

在这之前呢，我的框架更新了一个独立的网络模块，可以用于构建长连接网络游戏/应用。

它的特性如下:
1. 跨平台:适用于任意ts/js项目
2. 灵活、高可扩展:可以根据项目需要进行多层次定制
3. 零依赖
4. 强类型:基于TypeScript
5. 功能强大:提供完整的基本实现:握手、心跳、重连
6. 可靠:完善的单元测试

详细的可以点击传送门去了解:[enet](https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/packages/enet#readme)

那接下来，我带大家借助enet库实现

1. 一个带烟花效果的socket聊天demo(超简单，三步就可以)
   
2. 一个接近真实网络游戏开发的聊天室demo
   
玩起来~

## 带烟花效果的socket聊天demo

### 第一步:引入网络库并初始化

enet这个库，发布于npm公共仓库中。提供多种规范，适用于任何平台。

这次我们直接通过url引入iife格式的js

1. 创建html文件,引入enet库
```html

<!DOCTYPE html>
<html>

<div id="container"></div>

<script src="https://cdn.jsdelivr.net/npm/@ailhc/enet@1.0.0/dist/iife/lib/index.js"></script>

</body>

</html>

```
2. 初始化enet

```html
<script>
    var netNode = new enet.NetNode();
    //定制网络事件反馈逻辑
    netNode.init({
        netEventHandler: {
            //开始连接事件
            onStartConnenct: () => {
                console.log(`开始连接服务器`);
            },
            //连接成功事件
            onConnectEnd: () => {
                console.log(`连接服务器成功👌`);
            }
        }
    });
    
</script>
```
### 第二步: 写上收发消息的逻辑
就几句代码，so easy~
```html
<script>
    //省略初始化逻辑..
    //连上一个公用的websocket测试服务器,它会原本不动的返回发出的消息
    netNode.connect("wss://echo.websocket.org/");

    window.netNode = netNode;
    //封装发送消息逻辑，相当于微信发送按钮
    window.sendMsgToServer = function (msg) {
        if (!netNode.socket.isConnected) {
            console.warn(`服务器还没连上`);
            return;
        }
        netNode.notify("msg", msg);
    }
    //监听服务器消息返回
    netNode.onPush("msg", function (dpkg) {
        console.log(`服务器返回:`, dpkg.data);
    })
    
</script>
```
这个时候，我们就可以运行看看效果了
等待服务器连接成功（因为那个公用的测试服务器有时慢有时快）

在控制台输入 sendMsgToServer("hello enet")

![img](https://coding-pages-bucket-434147-7588795-4574-367535-1255530080.cos.ap-guangzhou.myqcloud.com/img/html-enet-test1.gif)

### 第三步:加上烟花效果

烟花效果网上扒来的
[快过年了，用JS让你的网页放烟花吧](https://blog.csdn.net/weixin_42686892/article/details/112589511)

在原来的代码里改
```html
<script>
  //省略
    window.sendMsgToServer = function (msg) {
        if (!netNode.socket.isConnected) {
            console.warn(`服务器还没连上`);
            return;
        }
        netNode.notify("msg", msg);
        checkAndFire(msg, true);
    }
    netNode.onPush("msg", function (dpkg) {
        console.log(`服务器返回:`, dpkg.data);
        checkAndFire(dpkg.data, false);
    })

    function checkAndFire(msg, left) {
        if (msg.includes("烟花") | msg.includes("🎇")) {
            fire(window.innerWidth * (left ? 1 / 3 : 2 / 3), window.innerHeight / 2);
        }
    }
</script>
```
运行起来，看看效果

![img](https://coding-pages-bucket-434147-7588795-4574-367535-1255530080.cos.ap-guangzhou.myqcloud.com/img/html-enet-test2.gif)

简单的仿微信聊天放烟花就这样了

[在线demo](https://ailhc.github.io/demos/enet-simple-demo)

[源码](https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/examples/egf-net-ws/egf-simple-net-client)

接下来，我们搞个大的。

## 聊天室demo

在实际的网络应用开发中，网络通信的需求会复杂许多。

1. 可能会使用协议包装通信数据进行传输
2. 可能会对通信数据进行加密
3. 可能会使用特殊的socket(socket.io)，甚至定制socket
4. 心跳处理
5. 握手处理
6. 断线重连处理
7. 等等

enet模块对上述情况都进行了封装，只需要根据enet提供的接口进行定制实现就可(无需改源码)

在这个聊天室demo中，我将使用protobuf作为通信协议。

### 为什么使用protobuf？

**什么是protobuf**

   > protobuf(Google Protocol Buffers)是Google提供一个具有高效的协议数据交换格式工具库(类似Json)，但相比于Json，Protobuf有更高的转化效率，时间效率和空间效率都是JSON的3-5倍。

   > protobuf提供了多种编程语言的支持：C++，JAVA，Python，C#，erlang等

**优势**
* 可以快速玩起来，统一的协议语言可以和多种后端语言快乐地玩起来，甚至多人sport

* 可以不用自己设计协议调协议那么苦逼。

来看看如何接入protobuf

### 使用protobuf

虽然不用自己设计协议，但怎么接入开发中还是需要的

常见的protobuf使用方式
1. 使用protobufjs库加载proto文件，然后进行协议编码解码
2. 使用protobuf工具将proto文件转成js文件+.d.ts声明文件，在项目中同时引入protobuf库和导出的js文件就可

我这里选择的方案是将proto文件转成js+.d.ts的方式使用。
* 优点:使用方便，适用于多种环境，有类型声明
* **会使js包体大些**。
   
这里的转换工具，我用自己开发的一个protobuf工具:[egf-protobuf](https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/packages/egf-protobuf-cli#readme)

一个字:强、稳如老狗

不多说，下次再写文介绍
1. 安装工具到全局或者项目目录
    ```bash
    npm install egf-protobuf -g
    或者
    npm install -S egf-protobuf
    ```
2. 在package.json写一下npm script
    ```json
    "scripts": {
        "genPb": "egf-pb g",
        "pbInit": "egf-pb i"
    }
    ```
3. 初始化项目 npm run pbInit
4. 创建proto文件目录protofiles
5. 写协议 pb_base.proto
   ```proto
    package pb_test;
    message HeartBeat {
        
    }
    message Kick {

    }
    //登录请求
    message Cs_Login {
        required string name = 1;
    }
    //登录返回
    message Sc_Login {
        required uint32 uid = 1;
    }

    //用户进来推送
    message Sc_userEnter {
        required string name = 1;
        required uint32 uid = 2;

    }
    //用户离开推送
    message Sc_userLeave {
        required uint32 uid = 2;

    }
    //消息结构
    message ChatMsg {
        required uint32 uid = 1;
        required string msg = 2;
    }
    //客户端发送消息
    message Cs_SendMsg {
        required ChatMsg msg = 1;
    }
    //服务器推送消息
    message Sc_Msg {
        required ChatMsg msg =1;
    }
   ```
6. 修改一下导出配置protobuf/epbconfig.js
    ```js
        /**.proto 文件夹路径  */
        sourceRoot: "protofiles",//指向创建的proto文件目录
        /**输出js文件名 */
        outFileName: "proto_bundle",
        /**生成js的输出路径 */
        outputDir: "egf-ccc-net-ws/assets/protojs",//客户端js文件输出目录
        /**声明文件输出路径 */
        dtsOutDir:  "egf-ccc-net-ws/libs",//客户端声明文件输出目录

    ```
    ps:由于后端用ts，所以也配置了后端文件导出路径
    ```js
    /**服务端输出配置 */
	serverOutputConfig: {
		/**protobufjs库输出目录 */
		pbjsLibDir: "egf-net-ws-server/libs",
        /**生成的proto js文件输出 */
		pbjsOutDir: "egf-net-ws-server/protojs",
        /**声明文件输出路径 */
		dtsOutDir: "egf-net-ws-server/libs"

	}
    ```
7. 导出proto为js和声明文件
    ```bash
        npm run genPb
    ```
8. 项目中引入protobufjs库和proto_bundle.js
   1. CocosCreator需要将它们设置为插件
   2. nodejs项目，需要使用require加载它们
    ```ts
    require("../libs/protobuf.js");
    require("../protojs/proto_bundle.js");
    ```
这样就可以在业务里愉快地使用protobuf来进行协议的编码解码了
```ts
//编码
const uint8arr = pb_test.ChatMsg.encode({ msg: "hello world", uid: 1 }).finish();
//解码
const msg: pb_test.IChatMsg = pb_test.ChatMsg.decode(uint8arr);
//结果: { msg: "hello world", uid: 1 }
```

### 在enet中使用protobuf

要在enet接入protobuf还需要简单的两步

1. 安装egf-pbws
   protobuf协议层使用已经实现的库[egf-pbws](https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/packages/enet-pbws#readme)

   已经发布到npm
   可以通过npm安装
   ```bash
   npm i egf-pbws
   ```
2. 初始化
   ```ts
   import { NetNode } from "@ailhc/enet";
   import { PbProtoHandler } from "@ailhc/enet-pbws";  
   const netMgr = new NetNode<string>();
   this._net = netMgr;
   //将协议编解码对象注入 我这里是pb_test
   const protoHandler = new PbProtoHandler(pb_test);
   netMgr.init({
        netEventHandler: this,
        protoHandler: protoHandler
    })
   ```
   
### CocosCreator2.4.2实现聊天客户端

这个客户端项目中写了3个例子
1. testcases/websocket-test 纯使用websocket+控制台打印的方式的例子
2. testcases/simple-test enet简单使用版本，没对协议层进行定制
3. testcases/protobuf-test protobuf协议定制版(今天的主角)

由于篇幅有限，UI组件的实现就不讲了，都是很简单的实现，具体可以直接看源码
传送门:[聊天客户端实现](https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/examples/egf-net-ws/egf-ccc-net-ws)

核心逻辑实现
```ts
const { ccclass, property } = cc._decorator;
import { NetNode } from "@ailhc/enet";
import { PbProtoHandler } from "@ailhc/enet-pbws";
import MsgPanel from "../../comps/msgPanel/MsgPanel";
@ccclass
export default class ProtobufNetTest extends cc.Component implements enet.INetEventHandler {
    //省略

    private _uid: number;
    userMap: { [key: number]: string } = {};
    private _userName: string;

    onLoad() {
        const netMgr = new NetNode<string>();
        this._net = netMgr;
        const protoHandler = new PbProtoHandler(pb_test);
        netMgr.init({
            netEventHandler: this,
            protoHandler: protoHandler
        })
        //监听消息推送
        netMgr.onPush<pb_test.ISc_Msg>("Sc_Msg", { method: this.onMsgPush, context: this });
        //监听用户进来
        netMgr.onPush<pb_test.ISc_userEnter>("Sc_userEnter", { method: this.onUserEnter, context: this });
        //监听用户离开
        netMgr.onPush<pb_test.ISc_userLeave>("Sc_userLeave", { method: this.onUserLeave, context: this });

    }
    /**
     * 连接服务器
     */
    connectSvr() {
        this._net.connect("ws://localhost:8181");
    }
    /**
     * 登录服务器
     */
    loginSvr() {
        let nameStr = this.nameInputEdit.string;
        if (!nameStr || !nameStr.length) {
            nameStr = "User";
        }
        this._net.request<pb_test.ICs_Login, pb_test.ISc_Login>("Cs_Login", { name: nameStr }, (data) => {
            if (!data.errorMsg) {
                this._userName = nameStr;
                this._uid = data.data.uid;
                this.hideLoginPanel();
                this.showChatPanel();
            }
        })
    }
    /**
     * 发送消息
     */
     sendMsg() {
        const msg = this.msgInputEdit.string;
        if (!msg) {
            console.error(`请输入消息文本`)
            return;
        }
        this._net.notify<pb_test.ICs_SendMsg>("Cs_SendMsg", { msg: { uid: this._uid, msg: msg } })
    }
    //用户进来处理
    onUserEnter(dpkg: enet.IDecodePackage<pb_test.ISc_userEnter>) {
        if (!dpkg.errorMsg) {
            this.userMap[dpkg.data.uid] = dpkg.data.name;
            this.msgPanelComp.addMsg({ name: "系统", msg: `[${dpkg.data.name}]进了` });
        } else {
            console.error(dpkg.errorMsg);
        }
    }
    //用户离开处理
    onUserLeave(dpkg: enet.IDecodePackage<pb_test.ISc_userLeave>) {
        if (!dpkg.errorMsg) {
            if (this.userMap[dpkg.data.uid]) {
                const leaveUserName = this.userMap[dpkg.data.uid];
                this.msgPanelComp.addMsg({ name: "系统", msg: `[${leaveUserName}]离开了` });
                delete this.userMap[dpkg.data.uid];
            }


        } else {
            console.error(dpkg.errorMsg);
        }
    }
    //消息下发处理
    onMsgPush(dpkg: enet.IDecodePackage<pb_test.ISc_Msg>) {
        if (!dpkg.errorMsg) {
            const svrMsg = dpkg.data.msg;
            let userName: string;
            if (this._uid === svrMsg.uid) {
                userName = "我";
            } else if (this.userMap[svrMsg.uid]) {
                userName = this.userMap[svrMsg.uid];
            } else {
                console.error(`没有这个用户:${svrMsg.uid}`)

            }
            if (userName) {
                const msgData = { name: userName, msg: svrMsg.msg }
                this.msgPanelComp.addMsg(msgData);
            }
        } else {
            console.error(dpkg.errorMsg);
        }
    }
    
    
    //#region 遮罩提示面板
    public showMaskPanel() {
        if (!this.maskPanel.active) this.maskPanel.active = true;
        if (!isNaN(this._hideMaskTimeId)) {
            clearTimeout(this._hideMaskTimeId);
        }
    }
    public updateMaskPanelTips(tips: string) {
        this.maskTips.string = tips;
    }
    private _hideMaskTimeId: number;
    public hideMaskPanel() {
        this._hideMaskTimeId = setTimeout(() => {
            this.maskPanel.active = false;
        }, 1000) as any;
    }
    //#endregion

    //#region 连接面板
    showConnectPanel() {
        this.connectPanel.active = true;
    }
    hideConnectPanel() {
        this.connectPanel.active = false;
    }
    //#endregion

    //#region 登录面板
    showLoginPanel() {
        this.loginPanel.active = true;
    }
    hideLoginPanel() {
        this.loginPanel.active = false;
    }
    //#endregion

    //#region 聊天面板
    showChatPanel() {
        this.chatPanel.active = true;
    }
    hideChatPanel() {
        this.chatPanel.active = false;
    }
    //#endregion

    onStartConnenct?(connectOpt: enet.IConnectOptions<any>): void {
        this.showMaskPanel()
        this.updateMaskPanelTips("连接服务器中");
    }
    onConnectEnd?(connectOpt: enet.IConnectOptions<any>): void {
        this.updateMaskPanelTips("连接服务器成功");
        this.hideMaskPanel();
        this.showLoginPanel();


    }
    //省略。。。    
}
```
效果图

**核心实现**

1. 协议层定制



### 




  




