{"meta":{"title":"晴","subtitle":"游戏,写代码,做个好游戏~","description":"分享个人游戏编程的心得~","author":"Tide Li","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2019-01-20T13:28:56.000Z","updated":"2020-10-17T06:49:00.944Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-01-20T13:29:32.000Z","updated":"2020-10-17T06:49:00.943Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-20T13:24:44.000Z","updated":"2020-10-17T06:49:00.946Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-17T06:49:00.945Z","updated":"2020-10-17T06:49:00.945Z","comments":true,"path":"categories/想法流水/index.html","permalink":"http://yoursite.com/categories/想法流水/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-17T06:49:00.944Z","updated":"2020-10-17T06:49:00.944Z","comments":true,"path":"categories/关于作者/index.html","permalink":"http://yoursite.com/categories/关于作者/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-17T06:49:00.945Z","updated":"2020-10-17T06:49:00.945Z","comments":true,"path":"categories/经验之谈/index.html","permalink":"http://yoursite.com/categories/经验之谈/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-17T06:49:00.945Z","updated":"2020-10-17T06:49:00.945Z","comments":true,"path":"categories/资料收集/index.html","permalink":"http://yoursite.com/categories/资料收集/index.html","excerpt":"","text":""}],"posts":[{"title":"CocosCreator2.x大项目卡顿终极解决方案","slug":"CocosCreator2.x大项目卡顿终极解决方案","date":"2021-06-13T04:56:34.000Z","updated":"2021-06-13T14:03:07.650Z","comments":false,"path":"2021/06/13/CocosCreator2.x大项目卡顿终极解决方案/","link":"","permalink":"http://yoursite.com/2021/06/13/CocosCreator2.x大项目卡顿终极解决方案/","excerpt":"","text":"前言论坛上有很多帖子、很多人说Creator大项目卡顿，也在苦苦寻找解决方案。 这对于每一个想用Creator做个大项目或者正在做着项目的小伙伴来说都是很难受的。 这可能会让他们割舍对Creator的喜爱，而另作选择。 或者在上了车之后，没法填这个坑导致项目黄了，那就更加难过了。 怎么办呢？我过年时就萌生了一个想法：我想摸一下Creator的上限。看看到底能不能解决大项目卡顿的问题，也是替各位小伙伴们探探路。 前段时间的探索，成功了。 那让我知道Creator开发大项目是完全没有问题的。 可以让我们用Creator爽，一直用一直爽的。 文章: 我想摸一下Creator的上限 上个星期有个深陷水深火热的小伙伴找到我，让我帮帮忙 能够帮到他，非常开心。 最近项目赶版本，比较忙，所以解决方案完善的进度慢了些。 虽迟但到~ 视频演示: https://www.bilibili.com/video/BV1hh411e7p5/ 插件地址: https://store.cocos.com/app/resources/search?name=Aswallow 我们感到难受的是什么？先说开发过程中让人感觉很舒服的一种情况 我改了一行代码，立刻就能看到运行情况 让人感觉难受的是什么？ 我改了一行代码，等了好久都没能运行起来 反馈的时间越短，越舒服 其实这里有一个很有趣的概念，叫即时反馈 ，它是进入心流状态的条件之一（就是那种很爽很沉醉的状态）有兴趣的可以查一下。 CocosCreator让我们在开发游戏过程中，能快速得到反馈 编辑场景，保存一下就可以刷新看结果 改一下代码，立刻编译看结果 修改shader立刻也能看到效果 遇到难点、bug翻一下论坛就能找到解决方案 这个就很舒服 但项目资源越多，这个改了一行代码，卡的时间就越长，越来越难受。 而项目后期大部分时间可能都是在改代码，也就意味着，一直卡。像吃屎一样。 其实。。。其实很多引擎在项目资源多的时候都会出现卡顿、反馈时间长等问题，这个是通病。 有问题就解决嘛。我们先找找原因 另外:CocosCreator已经做得很好了，不是吗？ 卡顿的根源:Creator编辑器的资源管理机制Creator编辑器会对所有资源进行分析，记录它们之间的依赖关系。 .meta文件就是记录资源的信息和依赖信息 资源的修改、增加、删除，都可能会导致依赖信息变化。 所以Creator会监视所有assets目录下的文件，当某个资源变动，编辑器都会遍历检查一下变动的影响。 这是为了保证依赖的准确性，如果依赖缺失了就会立刻提示你。 因此，当资源量多了，这个处理耗时就会变得越来越长。 这也是以下情况的缘由 保存一下prefab，卡顿好久 保存一下代码，切回来卡了好久 正所谓成也萧何败也萧何 解决思路：拆论坛上其实就有这个思路的方案，比如 将图片预先打成图集=&gt;减少图片资源量 将资源放到CDN Creator官方在Creator2.4.x版本也给出了他们的解决方案:AssetBundle 我觉得，在项目内分AssetBundle，卡顿问题还是没法解决的。因为资源量没变，处理耗时也也没有减少 但如果在另外一个项目制作资源的AssetBundle，然后导出。这个是可以解决问题的。 这些方案是有用，但就是有些麻烦，怎么才能做到更加方便和无感知呢？ 而且还有一个问题，怎么加载解析图集、龙骨、spine甚至fgui发布的资源和tilemap呢？ 因为官方的接口中，加载远程资源：只能加载简单的图片、音频、文本 文档传送门🚪:https://docs.cocos.com/creator/manual/zh/scripting/dynamic-load-resources.html 我的解决方案拆分资源的解决方案第一种:自定义网页预览不知道大家知不知道这个的存在。 文档传送门:https://docs.cocos.com/creator/manual/zh/advanced-topics/custom-preview-template.html 在项目根目录创建preview-templates，然后编辑器的预览功能就会以这个目录为入口 你将外部资源放到这个文件夹，使用远程加载接口，就可以加载到这里的资源 12345//直接将someres.png放到preview-templatesvar remoteUrl = \"someres.png\";cc.assetManager.loadRemote(remoteUrl, function (err, texture) &#123; // Use texture to create sprite frame&#125;); 但这样需要自己在构建时处理资源，复制到发布目录 第二种:插件 aswallow 如燕(谐音:爱上我咯) 开发预览支持 我通过hook creator的预览服务器逻辑，让你可以访问assets文件夹外的目录。对原来的预览服务器逻辑无影响 你只需将需要拆分出去的资源放到assets文件夹外的ext-res文件夹内即可 这个ext-res也可以通过修改local/aswallow-config.json来修改 发布构建支持 构建时，会自动将资源拷贝到构建输出目录，构建配置中的MD5Cache打开可以给文件名加md5，生成路径映射version.json文件 也可以自己实现自定义的构建处理逻辑,具体可见custom-build-scripts/custom-build.js 构建功能支持Creator2.3.x和2.4.x，以及发布构建支持：微信小游戏(其他小游戏没测，应该可以)、安卓原生、web 当然，如果配合下面的这个运行时会更完美 ps:听jare大佬说Assetbundle可以单独发布，我没找到。不过将资源项目发布到ext-res文件夹，就可以远程加载其中的bundle资源了 复杂资源加载解析方案这个其实挺苦恼的，官方没有接口。 我在论坛找到了龙骨的加载解析逻辑，然后断点运行看源码完善了。图集、spine、tilemap也是断点运行看源码实现的。 找到了解析方法后，基于此实现了 aswallow-asset-manager 它可以让你更加简单的加载外部、解析和管理外部资源(图集、龙骨、spine、tilemap、fgui发布的资源) 通过加载version文件，可以实现轻易加载解析加了md5后缀的资源（加载逻辑不变的情况下） 使用示例： 加载图集 1234567aswallow.extAssetMgr.load([&#123; url: \"atlas/emoji\", assetType: \"plist\" &#125;], (err, result) =&gt; &#123; console.log(result); const atlas = aswallow.extAssetMgr.get(\"atlas/emoji.plist\") as cc.SpriteAtlas; console.log(atlas); this.emojiSp.spriteFrame = atlas.getSpriteFrame(\"emoji1\") &#125;);&#125; 加载图片 12345678910111213141516171819202122232425262728let asset: cc.Asset;let index = 0;this._scheduleCallback = () =&gt; &#123; asset = aswallow.extAssetMgr.get(`$&#123;iconRoot&#125;/i$&#123;index&#125;.png`); index = Math.floor(Math.random() * 10); this.sp.spriteFrame = null; this.sp.spriteFrame = new cc.SpriteFrame(asset as cc.Texture2D);&#125;let iconRoot = \"fgui-res/Icons\";let resPaths = [];for (let i = 0; i &lt; 10; i++) &#123; resPaths.push(iconRoot + \"/i\" + i + \".png\");&#125;// cc.assetManager.preloadAny()aswallow.extAssetMgr.load(resPaths, (err, result: aswallow.ILoadResult) =&gt; &#123; if (!err) &#123; console.log(`加载成功`) console.log(result); this.schedule(this._scheduleCallback, 1, cc.macro.REPEAT_FOREVER); // this.sp.spriteFrame.ensureLoadTexture(); &#125;&#125;); 加载龙骨 12345678910111213141516171819const extAssetMgr = aswallow.extAssetMgr; extAssetMgr.load([ &#123; url: \"dragonbones/dragon/texture.json\", assetType: \"DragonBonesAtlasAsset\" &#125;, &#123; url: \"dragonbones/dragon/NewDragonTest.json\", assetType: \"DragonBonesAsset\" &#125;, \"dragonbones/dragon/texture.png\"], (err, items) =&gt; &#123; console.log(items) this.dragonBone_json.dragonAsset = extAssetMgr.get(\"dragonbones/dragon/NewDragonTest.json\") as any; this.dragonBone_json.dragonAtlasAsset = extAssetMgr.get(\"dragonbones/dragon/texture.json\") as any; this.dragonBone_json.armatureName = 'armatureName'; this.dragonBone_json.playAnimation('stand', 0); &#125;);//加载二进制extAssetMgr.load(&#123; url: \"dragonbones/sword-man/SwordsMan\", assetType: \"DragonBonesAsset\", ext: \".dbbin\" &#125;, (err, items) =&gt; &#123; this.dragonBone_bin.dragonAsset = extAssetMgr.get(\"dragonbones/sword-man/SwordsMan_ske.dbbin\") as any; this.dragonBone_bin.dragonAtlasAsset = extAssetMgr.get(\"dragonbones/sword-man/SwordsMan_tex.json\") as any; this.dragonBone_bin.armatureName = 'Swordsman-NestArmature'; this.dragonBone_bin.playAnimation('walk', 0);&#125;) 加载spine 123456789101112131415161718const extAssetMgr = aswallow.extAssetMgr;extAssetMgr.load([&#123; url: \"spines/spineboy/spineboy.json\", assetType: \"SpineAsset\" &#125;, \"spines/spineboy/spineboy.txt\", \"spines/spineboy/spineboy.png\"], (err, items) =&gt; &#123; console.log(items) this.spine_json.skeletonData = extAssetMgr.get(\"spines/spineboy/spineboy.json\") as any; this.spine_json.animation = 'run';&#125;);//加载二进制extAssetMgr.load([&#123; url: \"spines/spineRatorBin/raptor-pro.skel\", assetType: \"SpineAsset\" &#125;, \"spines/spineRatorBin/raptor-pro.atlas\", \"spines/spineRatorBin/raptor-pro.png\"], (err, items) =&gt; &#123; console.log(items) this.spine_bin.skeletonData = extAssetMgr.get(\"spines/spineRatorBin/raptor-pro.skel\") as any; this.spine_bin.animation = 'walk'; // this.spine._updateSkeletonData&#125;); 加载fgui 1//正常使用即可，接口没有变化 资源释放(以释放spine资源为例) 12345678aswallow.extAssetMgr.release([ &#123; url: \"spines/spineboy/spineboy.json\", assetType: \"SpineAsset\" &#125;, \"spines/spineboy/spineboy.txt\", \"spines/spineboy/spineboy.png\", &#123; url: \"spines/spineRatorBin/raptor-pro.skel\", assetType: \"SpineAsset\" &#125;, \"spines/spineRatorBin/raptor-pro.atlas\", \"spines/spineRatorBin/raptor-pro.png\"]) 暂时支持2.4.x，发布构建测试通过的平台：Android原生、web、微信小游戏(其他小游戏平台应该也可以) 最后CocosCreator其实是很强大的，不是吗？ 卡顿问题也是可以轻易解决的，不是吗？ 希望每个喜爱Cocos的小伙伴不用纠结要不要用Creator开发大项目 希望在开发大项目的小伙伴不再受卡顿之苦 希望每个CocosCreator项目都有所成~ 能帮到你们真的很开心。 如果喜欢我的解决方案，想一起玩转游戏开发 欢迎关注我的公众号 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/categories/EasyGameFramework/"}],"tags":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"}],"keywords":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/categories/EasyGameFramework/"}]},{"title":"年中总结","slug":"年中总结","date":"2021-05-04T02:25:00.000Z","updated":"2021-05-05T15:49:18.019Z","comments":false,"path":"2021/05/04/年中总结/","link":"","permalink":"http://yoursite.com/2021/05/04/年中总结/","excerpt":"","text":"前言这半年很充实，但有点累。有点累，但很充实。🤭 回顾一下工作之 YU ，做了一些事儿 迭代开源框架去年我开源了一个框架项目：EasyGameFramework:https://gitee.com/AIGAMESTUDIO.AILHC/EasyGameFrameworkOpen 随着不断的迭代，感觉它慢慢的变得更加强大，心中甚是喜悦。如果感兴趣可以look look，如果觉得不错可以点个小星星★ 最近也在想着改名，改一个更加合适的名字。之前想的是金箍棒~ 先讲一下最近更新的 臻于完美的模块构建工具我的初衷是做一个可以直接一键将功能模块打包成拥有不同模块规范的npm包，给不同的项目使用。 不用进行繁琐的配置。 因为这样方便进行模块级别的版本管理，不同的H5游戏引擎都可以轻松使用，达到跨项目，跨引擎的功能模块复用的目的。 一开始，只是能打包成js和单个d.ts声明文件，小问题挺多的，在后续的迭代中，改进了很多。 比如： vscode的自动导入识别错误（让人脑阔疼） CocosCreator3的ESM模块和CocosCreator2.x的Commonjs模块共存 自动/手动生成index.ts 完善扩展性（在开箱即用的情况下，又能进行自定义） 其他项目实践 通过开发cocosCreator的Typescript插件模板，让这个工具的扩展性变得更加强大，支持插件项目的编译和构建，打破玄学。 后来通过尝试构建输出CocosCreator3的 farygui 库，也有了打包大型框架库的实践。 后续的计划加入开发时的esbuild支持：更快，更强。 实现了display-ctrl的fairygui版本谷主发布了fairygui的CocosCreator3.0的适配：https://forum.cocos.org/t/topic/112136/5 而我抽空实现一下display-ctrl的fairygui实现:dpctrl-fgui 因为fairygui实现了不同引擎的适配嘛，所以这个模块不需要做太多也可以兼容不同引擎。（ps:就试了Laya和Cocos） 不需要做太多兼容，但还是要做的。。。因为Laya的实现和Cocos的实现中有微小的不同。。。 123456789101112131415161718192021//fgui-layer.ts...onSpAdd(sp: any): void &#123; const fgo = new fairygui.GObject(); //兼容cc/laya fgo[\"_displayObject\"] = sp;//Laya中的实现 fgo[\"_node\"] = sp;//Cocos中的实现 //兼容cc/laya sp[\"$owner\"] = fgo;//Laya中的实现 sp[\"$gobj\"] = fgo;//Cocos中的实现 this.addChild(fgo); &#125;...//fix-some-fgui.tsObject.defineProperty(fairygui.GObject.prototype, \"displayObject\", &#123; get: function () &#123; return this._node; &#125;, enumerable: false, configurable: true&#125;); 我更新了示例，感兴趣的可以看看 示例:http://aigamestudio.ailhc.gitee.io/easygameframeworkopen/examples/egf-ccc-full/ 我现在的公司项目是Laya+Fgui，算是深度使用Fgui了。 FairyGUI非常好用。 但如果有大量的包，而且不同包之间的有资源引用，Fgui官方的使用方式会是一种噩梦。而如果你要进行精确的资源内存管理的话，更是噩梦中的噩梦。 对于这种情况，我这边是写一个插件和配套的运行时，插件导出资源引用信息，提高开发和内存管理的效率。 完善通用对象池模块对象池是游戏开发中非常常用的一种模式，用于减少对象的频繁创建和销毁导致的性能压力。 Cocos中也有对象池模块:NodePool,Laya中也有一个全局的对象池模块Laya.Pool 这两个都有深入使用过。它们功能非常简单，在使用过程中往往需要加上自己的一些封装，或者是到处写一些重复的代码。 为了在不同的项目中重复造轮子，于是造了这个好用的对象池模块。 前段时间完善了它的类型提示，使用更加舒适。 并且增加了阈值控制系统，缓存数超过阈值就销毁，让池子不再无限暴涨 可以简单感受一下: 1234567891011121314151617181920212223242526272829303132333435363738394041//使用全局管理器const mgr = new ObjPoolMgr();//实现对象池接口class ClassA implements objPool.IObj&#123; onGet()&#123; &#125; onReturn()&#123; &#125; onKill()&#123; &#125;&#125;mgr.createObjPool(&#123;sign:\"test1\",clas:ClassA&#125;);const ins1 = mgr.get(\"test1\");//注入通用对象处理函数//这样对于没有实现IObj接口的对象也可以const objPool = new BaseObjPool();objPool.init( &#123; sign: \"pool1\", objHandler: &#123; onGet(obj: objPool.IObj, onGetData: any) &#123; &#125;, onCreate(obj): void &#123; &#125;, onReturn(obj): void &#123; &#125;, onKill(obj): void &#123; &#125; &#125; &#125;) 提示更加智能 12345678910111213141516interface ITestObjGetDataMap &#123; TestObj1: &#123; num: number &#125;, TestObj2: &#123; name: string &#125;, TestObj3: &#123; name: string &#125;&#125;const poolMgr = new ObjPoolMgr&lt;ITestObjGetDataMap&gt;();poolMgr.createByClass(\"TestObj1\", TestObj1);poolMgr.createByFunc(\"TestObj2\", () =&gt; &#123; return new TestObj2();&#125;);poolMgr.preCreate(\"TestObj1\", 5);//get 这里get可以获得对应\"TestObj1\"的传参类型提示const testObj1: TestObj1 = poolMgr.get(\"TestObj1\", &#123; num: 2 &#125;);//批量获取const testObj2s: TestObj2[] = poolMgr.getMore(\"TestObj2\", &#123; name: \"testObj2\" &#125;, 4); 阈值控制 1234567891011121314151617181920212223242526const objPool = new BaseObjPool();objPool.init( &#123; sign: \"pool1\", objHandler: &#123; onGet(obj: objPool.IObj, onGetData: any) &#123; &#125;, onCreate(obj): void &#123; &#125;, onReturn(obj): void &#123; &#125;, onKill(obj): void &#123; &#125; &#125;, //阈值 threshold: 100 &#125;)//回收对象，如果对象池里的数量大于等于100，则这个obj就会被kill掉（销毁）;objPool.return(obj); 再Q一下更早之前更新的 整了一个通用网络模块enet一个不受限于引擎和框架，易于使用并且能够扩展不同的底层以及上层显示的网络模块。 我做过几个项目，有用nodejs做后端的，有用nodejs的pomelo框架做后端的，有erlang做后端的，有用java的，使用的协议，网络交互底层都不太一样。 我都得去适配，去写一个网络模块。如果以后，还会遇到不同的后端，那我不太愿意再去重写一个网络模块了。我想用一个就够了。 过完年后，我花了一段时间，去整理提炼我之前项目写过的网络模块。 将它设计成一个，底层无关，业务无关的网络模块，并提供三层可扩展接口：显示层，协议层，socket层 并且实现了常见的网络交互组合：pomelo、websocket+protobuf、websocket 只要有需要就可以轻松替换不同的层，但面向业务的接口始终不变。 这是我写的一篇文章，可以了解一下： 一起聊天吃瓜放烟花:https://mp.weixin.qq.com/s/tzGzHhPYoIL10skjmuyO_Q 为了更方便使用protobuf之前我基于白鹭引擎组写的一个protobuf命令工具，写了一个适用于任意引擎的版本（给自己的Laya项目用）。 不满足于能用，为了更加方便，我重写了它。于是就有了egf-protobuf-cli 它的特性 提供 protobuf.js 基础运行时库 提供命令行脚本，将 protofile 生成 JavaScript 代码 生成正确的 .d.ts 代码，以方便 TypeScript 项目使用 理论上支持所有 HTML5 游戏引擎。欢迎使用 PIXI.js , Cocos2d-js , LayaAir 等其他引擎的开发者使用本库。 封装protobufjs的命令行，不需另外安装protobufjs 支持服务端文件同时输出 配置有智能提示 直接npm安装使用 1npm install egf-protobuf -g 具体可见:http://aigamestudio.ailhc.gitee.io/easygameframeworkopen/#/packages/egf-protobuf-cli/README 整工具可能有点香的解决方案很多人吐槽CocosCreator2.x资源多的时候卡顿，打开慢的问题。 原因可能大家都知道：编辑器会监听 assets 文件夹内的文件变动，并会做一些处理 其实我在想，其实很多资源其实没有必要放在assets目录，比如道具武器的icon资源、大量的序列帧图集等 我也相信CocosCreator肯定可以解析实例化外部资源(龙骨、tiledmap、图集、图片等) 所以我做了一个尝试:具体可见:https://mp.weixin.qq.com/s/t7664GuXvEWz2BKnbpPDCw 测试视频:https://www.bilibili.com/video/BV1WU4y1b7Es/ 最近增加了解析tiledmap资源逻辑 打包原生测试通过，相关工具快搞好了~ 可以稍稍期待一下😋 整一个相对好用的导表工具一开始我项目的导表工具是拿网上的来魔改，并且加上导出erlang用的文件的功能。 后来到了新的项目组，重写了一次，因为表格规范不一样，期间还迭代了两次 要加表头 表格文件多，导表速度慢了，增加增量导出功能 这一次是第三代了，一个更加强大、相对之前更加好用的一代。 它首先解决的问题是：根据项目需求自由扩展和自定义 支持多线程（表格文件越多，效果越好） 新的架构带来更强的自定义功能：自定义格式解析、自定义文件转换、自定义导出流程(比如：导出自动后上传ftp、提交svn) 我不想再写一次了。。。 顺便写了个typescript插件模板当时想开发CocosCreator插件，但是上手有丢丢麻烦。社区论坛有一些问题的答案和教程，但还是不爽。 为什么，就要一直玄学？就要用不完全又繁琐的typescript开发方式？ 工欲善其事必先利其器 虽然插件我现在还没做完。。。因为去捣鼓别的去了 来个视频感受一下 https://www.bilibili.com/video/BV1Ny4y1b7Vh 最后如果对游戏开发感兴趣的，想了解更多游戏开发相关的事和知识 可以关注公众号或者加群交流 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"想法流水","slug":"想法流水","permalink":"http://yoursite.com/categories/想法流水/"}],"tags":[{"name":"想法流水","slug":"想法流水","permalink":"http://yoursite.com/tags/想法流水/"}],"keywords":[{"name":"想法流水","slug":"想法流水","permalink":"http://yoursite.com/categories/想法流水/"}]},{"title":"我想摸一摸CocosCreator的上限","slug":"我想摸一摸CocosCreator的上限","date":"2021-04-18T09:28:08.000Z","updated":"2021-04-18T12:40:04.577Z","comments":false,"path":"2021/04/18/我想摸一摸CocosCreator的上限/","link":"","permalink":"http://yoursite.com/2021/04/18/我想摸一摸CocosCreator的上限/","excerpt":"","text":"前言Creator做游戏是真的方便。 但当游戏项目规模上升时，使用Creator开发就变得有点不舒服。 打开慢 切回编辑器卡顿 这些问题，相信很多人都有遇到过。也有很多人问，怎么解决？ 论坛里的解决方案 自己打图集 用mac 用固态硬盘 用高配置电脑 放到cdn 这些方案并可能有用，但感觉不太实际和靠谱，也没有具体的操作方案 疑问和比较CocosCreator能否舒服的开发大型项目？上限在哪里？ 论坛上也有一个帖子：是否有人比较过Laya、Egret、Cocos这几个引擎？ 里面的帖子和回复都很有意思，也挺有意义的。 我用Laya最多，相对感受也颇深，Laya的开发方式偏web Laya的IDE资源多的时候，导出也会卡，卡很久。 如果不是图集资源，或者用来拼UI的资源，一般不会放在assets目录 会放在最终导出的目录bin，也是预览服务器的静态资源目录 Creator大项目卡顿的原因是什么呢？ 比较直接的是：资源数量过多 导致启动项目会花很长时间去遍历处理资源 导致每次切回编辑器时花时间去做检索资源之类的操作 我的想法让Creator在开发预览时能加载使用不在assets的资源 然后在构建时，定制构建流程将外部资源处理发布到发布目录 这个也是我跟官方提的一个建议，但貌似没那么重视，哈哈哈 实现让Creator加载assets外的资源 使用预览模板 Creator预览服务器的静态资源目录在xxx\\Creator\\x.x.x\\resources\\static\\preview-templates 如果我们将它复制到我们项目目录下，那么预览服务器静态资源目录就指向我们项目目录下的preview-templates 我们可以将外部资源放到这个目录下 本地搭建个资源服务器 这个大家都懂，不细讲，就是麻烦而已 自己写个插件hook一下开发预览的资源加载（这是我选择的做法） 加载和解析复杂的资源(龙骨、图集)Creator加载远程的资源，只能加载并解析简单的 比如音频、文本、json、图片 但有些资源是组合的，需要我们自己下载并组装 比如图集、龙骨、spine 好在官方有demo和参考，以及可以调试源码来看如何构建那些资源并显示 这里我写了一个外部资源的加载和解析逻辑，方便加载和组装这些组合型资源 最终效果我用的是某西游项目，知道的人都知道，懂的人都懂 我的电脑配置: 那个项目的情况 它组织资源的方式比较粗暴 它在展示角色的界面用龙骨，在主城战斗中使用序列帧 大概有14000个资源放在resource，加上meta文件就约28000个文件 改造之后 将大约13000个资源移到外部 开发体验数据没使用之前 第一次10分14秒 第二次2分52秒 第三次2分53秒 第四次2分42秒 排除第一次：平均169秒 使用插件并改造之后 第一次3分22秒 第二次23秒 第三次24秒 第四次24秒 排除第一次：平均23.666秒 统计比较 第一次启动打开速度快了3倍 第一次之后的启动速度快了七倍 切回编辑器卡顿感明显减轻很多 适配情况 支持模拟器预览 支持微信小游戏 支持web发布 支持fairygui 后续计划 完善runtime 完善插件 最后上测试视频 解决方案测试视频：https://www.bilibili.com/video/av930007589 大项目测试视频：https://www.bilibili.com/video/av672691395 如果想要体验和测试欢迎关注公众号和加QQ群交流，测试项目就放在Q群 群里有个小伙伴说用了之后秒开。。。不知道是不是夸张，但应该是有效果的。 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"http://yoursite.com/tags/标签1/"},{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}]},{"title":"一起聊天吃瓜放烟花-仿微信聊天放烟花效果","slug":"一起聊天吃瓜放烟花","date":"2021-01-17T13:29:02.000Z","updated":"2021-04-18T09:27:04.585Z","comments":false,"path":"2021/01/17/一起聊天吃瓜放烟花/","link":"","permalink":"http://yoursite.com/2021/01/17/一起聊天吃瓜放烟花/","excerpt":"","text":"打个招呼大家好~ 游戏开发之路有趣但不易, 玩起来才能一直热情洋溢。 我是喜欢游戏开发的海潮😉 前言社交是人的基本需求。 互联网时代，基于互联网的社交带给网民们无穷的欢乐和瓜。 那些能够实时交互的社交软件/游戏，往往会带给我们更多惊喜。 最近微信更新了8.0版本，可以在聊天的时候放炸弹，烟花等动态表情。很多人都玩得不亦乐乎~ 在这之前呢，我的框架仓库增加了一个独立的网络模块，可以用于构建长连接网络游戏/应用。 特性: 跨平台:适用于任意ts/js项目 灵活、高可扩展:可以根据项目需要进行多层次定制 零依赖 强类型:基于TypeScript 功能强大:提供完整的基本需求实现(消息处理、握手、心跳、重连) 可靠:完善的单元测试 传送门:enet 那接下来，我带大家借助enet库实现 一个带烟花效果的socket demo(超简单，三步就可以) 一个接近真实网络游戏开发的多人聊天室demo 玩起来~ 极简聊天放烟花第一步:引入网络库并初始化enet这个库，发布于npm公共仓库中。提供多种规范，适用于任何平台。 这次我们直接通过url引入iife格式的js 创建html文件,引入enet库 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;div id=\"container\"&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/@ailhc/enet@1.0.0/dist/iife/lib/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 初始化enet 1234567891011121314151617&lt;script&gt; var netNode = new enet.NetNode(); //定制网络事件反馈逻辑 netNode.init(&#123; netEventHandler: &#123; //开始连接事件 onStartConnenct: () =&gt; &#123; console.log(`开始连接服务器`); &#125;, //连接成功事件 onConnectEnd: () =&gt; &#123; console.log(`连接服务器成功👌`); &#125; &#125; &#125;); &lt;/script&gt; 第二步: 写上收发消息的逻辑就几句代码，so easy~1234567891011121314151617181920&lt;script&gt; //省略初始化逻辑.. //连上一个公用的websocket测试服务器,它会原本不动的返回发出的消息 netNode.connect(\"wss://echo.websocket.org/\"); window.netNode = netNode; //封装发送消息逻辑，相当于微信发送按钮 window.sendMsgToServer = function (msg) &#123; if (!netNode.socket.isConnected) &#123; console.warn(`服务器还没连上`); return; &#125; netNode.notify(\"msg\", msg); &#125; //监听服务器消息返回 netNode.onPush(\"msg\", function (dpkg) &#123; console.log(`服务器返回:`, dpkg.data); &#125;) &lt;/script&gt; 这个时候，我们就可以运行看看效果了等待服务器连接成功（因为那个公用的测试服务器有时慢有时快） 在控制台输入 sendMsgToServer(“hello enet”) 第三步:加上烟花效果烟花效果网上扒来的快过年了，用JS让你的网页放烟花吧 在原来的代码里改1234567891011121314151617&lt;script&gt; //省略 window.sendMsgToServer = function (msg) &#123; /**省略*/ checkAndFire(msg, true); &#125; netNode.onPush(\"msg\", function (dpkg) &#123; console.log(`服务器返回:`, dpkg.data); checkAndFire(dpkg.data, false); &#125;) function checkAndFire(msg, left) &#123; if (msg.includes(\"烟花\") | msg.includes(\"🎇\")) &#123; fire(window.innerWidth * (left ? 1 / 3 : 2 / 3), window.innerHeight / 2); &#125; &#125;&lt;/script&gt; 运行起来，看看效果 简单的仿微信聊天放烟花就这样了 在线demo 源码 接下来，我们搞个大的。 多人聊天放烟花在实际的网络应用开发中，网络通信的需求会复杂许多。 可能会使用协议包装通信数据进行传输 可能会对通信数据进行加密 可能会使用特殊的socket(socket.io)，甚至定制socket 心跳处理 握手处理 断线重连处理 enet模块对上述情况都进行了封装，只需要根据提供的接口进行实现就可(无需改源码) 在这个多人聊天室demo中，我将使用protobuf作为通信协议。 为什么使用protobuf？什么是protobuf protobuf(Google Protocol Buffers)是Google提供一个具有高效的协议数据交换格式工具库(类似Json)，但相比于Json，Protobuf有更高的转化效率，时间效率和空间效率都是JSON的3-5倍。 protobuf提供了多种编程语言的支持：C++，JAVA，Python，C#，erlang等 优势 可以快速玩起来，统一的协议语言可以和多种后端语言快乐地玩起来，甚至多人sport🤪👩🏿‍🤝‍🧑🏿👬👨🏾‍🤝‍👨🏼 不用自己设计协议和实现协议编解码 👀来看看如何接入protobuf 使用protobuf虽然不用自己设计协议，但怎么接入开发中还是需要滴 常见的protobuf使用方式 使用protobufjs库加载proto文件，然后进行协议编码解码 使用protobuf工具将proto文件转成js文件+.d.ts声明文件，在项目中同时引入protobuf库和导出的js文件就可 我这里选择第二种方案 优点:使用方便，适用于多种环境，有类型声明 缺点: 会使js包体大些。 为了方便协议的导出，我用自己开发的一个protobuf工具:egf-protobuf 安装工具到全局或者项目目录 123npm install egf-protobuf -g或者npm install -S egf-protobuf 在package.json写一下npm script 1234\"scripts\": &#123; \"genPb\": \"egf-pb g\", \"pbInit\": \"egf-pb i\"&#125; 初始化项目 npm run pbInit 创建proto文件目录protofiles 写协议 pb_base.proto 12345678910111213141516171819202122232425262728293031323334353637package pb_test;message User &#123; required uint32 uid = 1; required string name = 2;&#125; //登录请求message Cs_Login &#123; required string name = 1;&#125;//登录返回message Sc_Login &#123; required uint32 uid = 1; repeated User users = 2;&#125; //用户进来推送message Sc_userEnter &#123; required User user = 1;&#125; //用户离开推送message Sc_userLeave &#123; required uint32 uid = 2;&#125;//消息结构 message ChatMsg &#123; required uint32 uid = 1; required string msg = 2;&#125;//客户端发送消息message Cs_SendMsg &#123; required ChatMsg msg = 1;&#125;//服务器推送消息message Sc_Msg &#123; required ChatMsg msg =1;&#125; 修改一下导出配置protobuf/epbconfig.js 12345678/**.proto 文件夹路径 */sourceRoot: \"protofiles\",//指向创建的proto文件目录/**输出js文件名 */outFileName: \"proto_bundle\",/**生成js的输出路径 */outputDir: \"egf-ccc-net-ws/assets/protojs\",//客户端js文件输出目录/**声明文件输出路径 */dtsOutDir: \"egf-ccc-net-ws/libs\",//客户端声明文件输出目录 ps:由于后端用ts，所以也配置了后端文件导出路径(前后端同时导出=双倍的快乐🤞🏻✌🏻) 12345678910/**服务端输出配置 */serverOutputConfig: &#123; /**protobufjs库输出目录 */ pbjsLibDir: \"egf-net-ws-server/libs\", /**生成的proto js文件输出 */ pbjsOutDir: \"egf-net-ws-server/protojs\", /**声明文件输出路径 */dtsOutDir: \"egf-net-ws-server/libs\" &#125; 导出js和.d.ts 1npm run genPb 项目中引入protobufjs库和proto_bundle.js CocosCreator需要将它们设置为插件 nodejs项目，需要使用require加载它们12require(\"../libs/protobuf.js\");require(\"../protojs/proto_bundle.js\"); 这样就可以在业务里愉快地使用protobuf来进行协议的编码解码了 12345//编码const uint8arr = pb_test.ChatMsg.encode(&#123; msg: \"hello world\", uid: 1 &#125;).finish();//解码const msg: pb_test.IChatMsg = pb_test.ChatMsg.decode(uint8arr);//结果: &#123; msg: \"hello world\", uid: 1 &#125; 将enet和protobuf结合起来enet中如果需要自定义协议处理则需要实现enet.IProtoHandler接口 12345678910111213141516171819202122232425262728interface IProtoHandler&lt;ProtoKeyType = any&gt; &#123; /** * 协议key转字符串key * @param protoKey */ protoKey2Key(protoKey: ProtoKeyType): string; /** * 编码数据包 * @param pkg * @param useCrypto 是否加密 */ encodePkg&lt;T&gt;(pkg: enet.IPackage&lt;T&gt;, useCrypto?: boolean): NetData; /** * 编码消息数据包 * @param msg 消息包 * @param useCrypto 是否加密 */ encodeMsg&lt;T&gt;(msg: enet.IMessage&lt;T, ProtoKeyType&gt;, useCrypto?: boolean): NetData; /** * 解码网络数据包， * @param data */ decodePkg&lt;T&gt;(data: NetData): IDecodePackage&lt;T&gt;; /** * 心跳配置 */ heartbeatConfig: enet.IHeartBeatConfig;&#125; 举个栗子🌰 我需要使用protobuf协议进行通信 那我就实现接口写一个protobuf协议处理器。 比如:egf-pbws 简单两步用起来(☞ﾟヮﾟ)☞ 安装egf-pbws 1npm i egf-pbws 和enet结合12345678910import &#123; NetNode &#125; from \"@ailhc/enet\";import &#123; PbProtoHandler &#125; from \"@ailhc/enet-pbws\"; const netMgr = new NetNode&lt;string&gt;();this._net = netMgr;//将协议编解码对象注入 我这里是pb_testconst protoHandler = new PbProtoHandler(pb_test);netMgr.init(&#123; netEventHandler: this, protoHandler: protoHandler &#125;) 准备工作做好了，开始写客户端 CocosCreator2.4.2实现多人聊天客户端这个客户端项目中写了3个例子 testcases/websocket-test 纯使用websocket+控制台打印的方式的例子 testcases/simple-test enet简单使用版本，没对协议层进行定制 testcases/protobuf-test protobuf协议定制版(今天的主角) 由于篇幅有限，UI组件的实现就不讲了，都是很简单的实现，具体可以直接看源码 传送门:聊天客户端实现 核心逻辑实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185const &#123; ccclass, property &#125; = cc._decorator;import &#123; NetNode &#125; from \"@ailhc/enet\";import &#123; PbProtoHandler &#125; from \"@ailhc/enet-pbws\";import MsgPanel from \"../../comps/msgPanel/MsgPanel\";@ccclassexport default class ProtobufNetTest extends cc.Component implements enet.INetEventHandler &#123; //省略 private _uid: number; userMap: &#123; [key: number]: string &#125; = &#123;&#125;; private _userName: string; onLoad() &#123; const netMgr = new NetNode&lt;string&gt;(); this._net = netMgr; const protoHandler = new PbProtoHandler(pb_test); netMgr.init(&#123; netEventHandler: this, protoHandler: protoHandler &#125;) //监听消息推送 netMgr.onPush&lt;pb_test.ISc_Msg&gt;(\"Sc_Msg\", &#123; method: this.onMsgPush, context: this &#125;); //监听用户进来 netMgr.onPush&lt;pb_test.ISc_userEnter&gt;(\"Sc_userEnter\", &#123; method: this.onUserEnter, context: this &#125;); //监听用户离开 netMgr.onPush&lt;pb_test.ISc_userLeave&gt;(\"Sc_userLeave\", &#123; method: this.onUserLeave, context: this &#125;); &#125; /** * 连接服务器 */ connectSvr() &#123; this._net.connect(\"ws://localhost:8181\"); &#125; /** * 登录服务器 */ loginSvr() &#123; let nameStr = this.nameInputEdit.string; if (!nameStr || !nameStr.length) &#123; nameStr = \"User\"; &#125; this._net.request&lt;pb_test.ICs_Login, pb_test.ISc_Login&gt;(\"Cs_Login\", &#123; name: nameStr &#125;, (dpkg) =&gt; &#123; if (!dpkg.errorMsg) &#123; this._userName = nameStr; this._uid = dpkg.data.uid; const users = dpkg.data.users; if (users &amp;&amp; users.length) &#123; for (let i = 0; i &lt; users.length; i++) &#123; const user = users[i]; this.userMap[user.uid] = user.name; &#125; &#125; this.hideLoginPanel(); this.showChatPanel(); &#125; &#125;) &#125; /** * 发送消息 */ sendMsg() &#123; const msg = this.msgInputEdit.string; if (!msg) &#123; console.error(`请输入消息文本`) return; &#125; this.msgInputEdit.string = \"\"; this._net.notify&lt;pb_test.ICs_SendMsg&gt;(\"Cs_SendMsg\", &#123; msg: &#123; uid: this._uid, msg: msg &#125; &#125;) &#125; //用户进来处理 onUserEnter(dpkg: enet.IDecodePackage&lt;pb_test.ISc_userEnter&gt;) &#123; if (!dpkg.errorMsg) &#123; const enterUser = dpkg.data.user; this.userMap[enterUser.uid] = enterUser.name; this.msgPanelComp.addMsg(&#123; name: \"系统\", msg: `[$&#123;enterUser.name&#125;]进来了` &#125;); &#125; else &#123; console.error(dpkg.errorMsg); &#125; &#125; //用户离开处理 onUserLeave(dpkg: enet.IDecodePackage&lt;pb_test.ISc_userLeave&gt;) &#123; if (!dpkg.errorMsg) &#123; if (this.userMap[dpkg.data.uid]) &#123; const leaveUserName = this.userMap[dpkg.data.uid]; this.msgPanelComp.addMsg(&#123; name: \"系统\", msg: `[$&#123;leaveUserName&#125;]离开了` &#125;); delete this.userMap[dpkg.data.uid]; &#125; &#125; else &#123; console.error(dpkg.errorMsg); &#125; &#125; //消息下发处理 onMsgPush(dpkg: enet.IDecodePackage&lt;pb_test.ISc_Msg&gt;) &#123; if (!dpkg.errorMsg) &#123; const svrMsg = dpkg.data.msg; let userName: string; let isSelf: boolean; if (this._uid === svrMsg.uid) &#123; userName = \"我\"; isSelf = true; &#125; else if (this.userMap[svrMsg.uid]) &#123; userName = this.userMap[svrMsg.uid]; &#125; else &#123; console.error(`没有这个用户:$&#123;svrMsg.uid&#125;`) &#125; if (userName) &#123; const msgData = &#123; name: userName, msg: svrMsg.msg &#125; //判断是否放烟花 this.checkAndFire(svrMsg.msg, isSelf); this.msgPanelComp.addMsg(msgData); &#125; &#125; else &#123; console.error(dpkg.errorMsg); &#125; &#125; //#region 遮罩提示面板 public showMaskPanel() &#123; if (!this.maskPanel.active) this.maskPanel.active = true; if (!isNaN(this._hideMaskTimeId)) &#123; clearTimeout(this._hideMaskTimeId); &#125; &#125; public updateMaskPanelTips(tips: string) &#123; this.maskTips.string = tips; &#125; private _hideMaskTimeId: number; public hideMaskPanel() &#123; this._hideMaskTimeId = setTimeout(() =&gt; &#123; this.maskPanel.active = false; &#125;, 1000) as any; &#125; //#endregion //#region 连接面板 showConnectPanel() &#123; this.connectPanel.active = true; &#125; hideConnectPanel() &#123; this.connectPanel.active = false; &#125; //#endregion //#region 登录面板 showLoginPanel() &#123; this.loginPanel.active = true; &#125; hideLoginPanel() &#123; this.loginPanel.active = false; &#125; //#endregion //#region 聊天面板 showChatPanel() &#123; this.chatPanel.active = true; &#125; hideChatPanel() &#123; this.chatPanel.active = false; &#125; //#endregion onStartConnenct?(connectOpt: enet.IConnectOptions&lt;any&gt;): void &#123; this.showMaskPanel() this.updateMaskPanelTips(\"连接服务器中\"); &#125; onConnectEnd?(connectOpt: enet.IConnectOptions&lt;any&gt;): void &#123; this.updateMaskPanelTips(\"连接服务器成功\"); this.hideMaskPanel(); this.showLoginPanel(); &#125; //判断并放烟花 checkAndFire(msg: string, left: boolean) &#123; if (msg.includes(\"烟花\") || msg.includes(\"🎇\")) &#123; window.fire(window.innerWidth * 1 / 2 + (left ? -100 : 100), window.innerHeight / 2); &#125; &#125; //省略。。。 &#125; 烟花效果代码实现 12345678910111213141516171819202122232425262728293031//烟花代码,稍微修改一下(function () &#123; var cdom = document.createElement(\"canvas\"); cdom.id = \"myCanvas\"; cdom.style.position = \"fixed\"; cdom.style.left = \"0\"; cdom.style.top = \"0\"; cdom.style.zIndex = 1; document.body.appendChild(cdom); var canvas = document.getElementById('myCanvas'); var context = canvas.getContext('2d'); cdom.style.background = \"rgba(255,255,255,0)\"//背景透明 cdom.style.pointerEvents = \"none\";//让这个canvas的点击穿透 function resizeCanvas() &#123; canvas.width = window.innerWidth; canvas.height = window.innerHeight; &#125; window.addEventListener('resize', resizeCanvas, false); resizeCanvas(); clearCanvas(); function clearCanvas() &#123; // context.fillStyle = '#000000'; // context.fillRect(0, 0, canvas.width, canvas.height); &#125; var rid; window.fire = function fire(x, y) &#123; createFireworks(x, y); function tick() &#123; context.globalCompositeOperation = 'destination-out'; context.fillStyle = 'rgba(0,0,0,' + 10 / 100 + ')'; context.fillRect(0, 0, canvas.width, canvas.height); context.globalCompositeOperation = 'lighter'; drawFireworks(); rid = requestAnimationFrame(tick); &#125; cancelAnimationFrame(rid); tick(); &#125; var particles = []; function createFireworks(sx, sy) &#123; particles = []; var hue = Math.floor(Math.random() * 51) + 150; var hueVariance = 30; var count = 100; for (var i = 0; i &lt; count; i++) &#123; var p = &#123;&#125;; var angle = Math.floor(Math.random() * 360); p.radians = angle * Math.PI / 180; p.x = sx; p.y = sy; p.speed = (Math.random() * 5) + .4; p.radius = p.speed; p.size = Math.floor(Math.random() * 3) + 1; p.hue = Math.floor(Math.random() * ((hue + hueVariance) - (hue - hueVariance))) + (hue - hueVariance); p.brightness = Math.floor(Math.random() * 31) + 50; p.alpha = (Math.floor(Math.random() * 61) + 40) / 100; particles.push(p); &#125; &#125; function drawFireworks() &#123; clearCanvas(); for (var i = 0; i &lt; particles.length; i++) &#123; var p = particles[i]; var vx = Math.cos(p.radians) * p.radius; var vy = Math.sin(p.radians) * p.radius + 0.4; p.x += vx; p.y += vy; p.radius *= 1 - p.speed / 100; p.alpha -= 0.005; context.beginPath(); context.arc(p.x, p.y, p.size, 0, Math.PI * 2, false); context.closePath(); context.fillStyle = 'hsla(' + p.hue + ', 100%, ' + p.brightness + '%, ' + p.alpha + ')'; context.fill(); &#125; &#125; // document.addEventListener('mousedown', mouseDownHandler, false);&#125;)(); 界面效果图 node+TypeScript实现简易后端我最熟悉node，而且可以共用enet-pbws的这个protobuf协议处理库 就几行代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import WebSocket = require(\"ws\")import config from \"./config\";import &#123; PackageType, PbProtoHandler &#125; from \"@ailhc/enet-pbws\";//引入protobuf库require(\"../libs/protobuf.js\");//引入转译后的protojs文件require(\"../protojs/proto_bundle.js\");import &#123; &#125; from \"@ailhc/enet\"export class App &#123; private _svr: WebSocket.Server; private _clientMap: Map&lt;number, ClientAgent&gt;; private _uid: number = 1; public protoHandler: PbProtoHandler; constructor() &#123; this.protoHandler = new PbProtoHandler(global.pb_test) const wsvr = new WebSocket.Server(&#123; port: config.port &#125;); this._svr = wsvr; this._clientMap = new Map(); wsvr.on('connection', (clientWs) =&gt; &#123; console.log('client connected'); this._clientMap.set(this._uid, new ClientAgent(this, this._uid, clientWs)); this._uid++; &#125;); wsvr.on(\"close\", () =&gt; &#123; &#125;); console.log(`服务器启动:监听端口:$&#123;config.port&#125;`); &#125; sendToAllClient(data: enet.NetData) &#123; this._clientMap.forEach((client) =&gt; &#123; client.ws.send(data); &#125;) &#125; sendToOhterClient(uid: number, data: enet.NetData) &#123; this._clientMap.forEach((client) =&gt; &#123; if (client.uid !== uid) &#123; client.ws.send(data); &#125; &#125;) &#125; sendToClient(uid: number, data: enet.NetData) &#123; const client = this._clientMap.get(uid); client.ws.send(data); &#125; onUserLogin(user: pb_test.IUser, reqId: number) &#123; const users: pb_test.IUser[] = []; const encodeData = this.protoHandler.encodeMsg&lt;pb_test.Sc_Login&gt;(&#123; key: \"Sc_Login\", data: &#123; uid: user.uid, users: users &#125;, reqId: reqId &#125;); this.sendToClient(user.uid, encodeData); const enterEncodeData = this.protoHandler.encodeMsg&lt;pb_test.Sc_userEnter&gt;(&#123; key: \"Sc_userEnter\", data: &#123; user: user &#125; &#125;) this.sendToOhterClient(user.uid, enterEncodeData); &#125;&#125;//客户端代理export class ClientAgent &#123; private loginData: pb_test.ICs_Login; constructor(public app: App, public uid: number, public ws: WebSocket) &#123; ws.on('message', this.onMessage.bind(this)); ws.on(\"close\", this.onClose.bind(this)); ws.on(\"error\", this.onError.bind(this)); &#125; public get user(): pb_test.IUser &#123; return &#123; uid: this.uid, name: this.loginData.name &#125;; &#125; private onMessage(message) &#123; if (typeof message === \"string\") &#123; //TODO 字符串处理 &#125; else &#123; //protobuf处理 const dpkg = this.app.protoHandler.decodePkg(message); if (dpkg.errorMsg) &#123; console.error(`解析客户端uid:$&#123;this.uid&#125;消息错误:`, dpkg.errorMsg); return; &#125; if (dpkg.type === PackageType.DATA) &#123; this[dpkg.key] &amp;&amp; this[dpkg.key](dpkg) &#125; &#125; &#125; private Cs_Login(dpkg: enet.IDecodePackage&lt;pb_test.Cs_Login&gt;) &#123; this.loginData = dpkg.data; this.app.onUserLogin(this.user, dpkg.reqId); &#125; private Cs_SendMsg(dpkg: enet.IDecodePackage&lt;pb_test.Cs_SendMsg&gt;) &#123; const encodeData = this.app.protoHandler.encodeMsg&lt;pb_test.Sc_Msg&gt;(&#123; key: \"Sc_Msg\", data: dpkg.data &#125;); this.app.sendToAllClient(encodeData); &#125; private onError(err: Error) &#123; console.error(err); &#125; private onClose(code: number, reason: string) &#123; console.error(`$&#123;this.uid&#125; 断开连接:code$&#123;code&#125;,reason:$&#123;reason&#125;`); const leaveEncodeData = this.app.protoHandler.encodeMsg&lt;pb_test.Sc_userLeave&gt;(&#123; key: \"Sc_userLeave\", data: &#123; uid: this.uid &#125; &#125;) this.app.sendToOhterClient(this.uid, leaveEncodeData); &#125;&#125;(new App()) 开启多人Sport聊天启动项目 初始化项目 在/examples/egf-net-ws目录，打开终端 1npm install 如果有yarn则可以 1yarn install 启动服务器(还是在刚刚的目录下) 1npm run star-svr 或者 npm run dev_svr 服务器启动成功: 1服务器启动:监听端口:8181 启动客户端:用CocosCreator2.4.2打开项目 最终效果 一起聊天放烟花 总结 第一个demo，借助enet通过简单的几句代码就可以实现socket收发消息 第二个demo，借助enet以及egf-protobuf和enet-pbws可轻松实现基于protobuf协议的多人聊天室应用 由于篇幅有限，有些功能没有讲到 自定义握手处理 自定义socket层 自定义网络反馈层(比如：发送请求就弹出请求中遮罩，请求结束自动关闭遮罩等) 心跳处理 重连处理 后续将分享一下，如何设计enet 最后我是喜欢游戏开发的海潮😉 持续学习，持续up，分享游戏开发心得，玩转游戏开发 游戏开发之路有趣但不易, 玩起来才能一直热情洋溢。 欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/categories/EasyGameFramework/"},{"name":"想法流水","slug":"EasyGameFramework/想法流水","permalink":"http://yoursite.com/categories/EasyGameFramework/想法流水/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"Discussion","slug":"Discussion","permalink":"http://yoursite.com/tags/Discussion/"},{"name":"enet","slug":"enet","permalink":"http://yoursite.com/tags/enet/"}],"keywords":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/categories/EasyGameFramework/"},{"name":"想法流水","slug":"EasyGameFramework/想法流水","permalink":"http://yoursite.com/categories/EasyGameFramework/想法流水/"}]},{"title":"我的2020","slug":"我的2020","date":"2020-12-31T15:37:00.000Z","updated":"2021-01-17T14:59:42.158Z","comments":false,"path":"2020/12/31/我的2020/","link":"","permalink":"http://yoursite.com/2020/12/31/我的2020/","excerpt":"","text":"异乎寻常的一年因为疫情，这一年变得异乎寻常。没有任何时候，比疫情的时候感到活着不易。 所以2020这一年，我希望好好活着。 好好的活着，比什么都好。 希望项目能够成功从毕业到现在已经2年半了，第一个项目，一个用Laya做的3D卡牌H5项目，我半路接手，和小伙伴们倾注全力，最终还是被砍掉了。 第二个项目，一个用Laya做的挂机3drpg，这是我第一次参与做这么复杂庞大的项目，很累但很有成就感。幸亏有项目组的小伙伴们的一起努力，才能有这样的成果： 有公司签了，也准备上线了。 希望它能成功上线，大赚。 第三个项目，也就是我现在做的项目，一个3d卡牌H5项目，是的又回到了做卡牌。我已经加入这个项目半年了，我是中途加入的，之前他们做了战斗demo。 经过大家的六个月的努力，现在它已经有点像样了，年前应该有个测试版本要上线吧。 希望能顺利做完上线，大赚。 有所收获做项目这么久了，其实很累，因为有很多工作，反反复复。 无论在哪个项目组，人手都不算多，但任务又那么多，老板催得那么紧。 怎么样才能让开发更加高效，是我一直在思考，也是一直在尝试和实践。 有的有用，有的没用。所幸，是有用的更多。 在不断思考和实践中，我收获了很多。 沉淀积累项目千差万别，但核心功能需求大同小异。 这是我一直以来隐隐的感觉，我觉得我可以梳理出来。 我想将我的经验和收获沉淀，写一个通用的开发框架。 那是我2020年的第二个flag，好好活着就得搞点事情。 它就是：EasyGameFramework 基于TypeScript，超强类型提示 跨引擎通用，高度可定制 渐进式 零依赖 基础模块全面(模块管理、UI框架、事件通讯、状态管理、对象池、网络模块) 12月初，我开源了这个框架，并在后续，分享了我写这个框架各个模块的所思所想。 这个仓库收获了26个star，谢谢这26个人的认可和肯定。 如果你们也觉得不错，点个star哦。 希望我稚嫩的笔触，能让大家有所收获。 2021展望首先是和小伙伴们一起将手上的项目做好，送上线。 其次是EasyGameFramework 这个框架，我将继续维护和发展。 更加规范的工程化 共建计划(一起来成为这个框架的contributor吧~) 项目模板自动生成 更多通用模块 数据驱动的通用战斗模块 ECS模块 。。。 更多有用的工具模块和Cocos组件 最后是做自己的游戏，梦想还是要有的，是吧，哈哈哈😝 目标:星辰大海~ 最后在2020的最后一天，无论过去如何，新的一年，过得更加Easy，游戏开发更加Easy，收获多多，积累多多~ 元旦快乐~ 欢迎关注我的公众号，更多干货内容持续更新~ 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"想法流水","slug":"想法流水","permalink":"http://yoursite.com/categories/想法流水/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"想法流水","slug":"想法流水","permalink":"http://yoursite.com/tags/想法流水/"}],"keywords":[{"name":"想法流水","slug":"想法流水","permalink":"http://yoursite.com/categories/想法流水/"}]},{"title":"构建复杂游戏/应用的神器:broadcast","slug":"构建复杂游戏-应用的神器-broadcast","date":"2020-12-27T12:44:46.000Z","updated":"2020-12-27T15:00:40.782Z","comments":false,"path":"2020/12/27/构建复杂游戏-应用的神器-broadcast/","link":"","permalink":"http://yoursite.com/2020/12/27/构建复杂游戏-应用的神器-broadcast/","excerpt":"","text":"前言事件机制,相信很多人都知道，了解，也经常用到。 在设计模式中，它叫 观察者模式（又叫发布-订阅模式）。 它无处不在: 在Java中，它是Java的核心库java.utils.Observable， 在C#中，为它提供了语法糖支持:event关键字 在web浏览器的Javascript中，有内置的事件机制:window.addEventListener,Event 在Nodejs中，也有内置库events 在游戏引擎中也都是内置的存在 CocosCreator的cc.EventTarget Laya的Laya.EventDispatcher 其他引擎都有 使用这种模式可以让我们更好地解耦游戏业务逻辑。 但是 这些事件机制的在Js和ts中的实现没能让我觉得满意（我都是使用过），总觉得缺了点什么。 携带数据没类型提示 消息发送者，没法获得要发送消息携带的数据类型提示 消息接收者，没法获得发送过来的数据类型提示 面对复杂的通信情况，没内置支持 想在消息发送点，接收到，消息接收器返回的数据(如果自己实现，将回调包在数据中传给消息接收者，让它执行这个回调) 事件发出去了，但消息接收者还没注册，错过了 不内置支持状态管理 很多时候，我们会遇到类似这种需求： 很多地方需要监听角色等级变化事件然后去角色信息接口取角色等级状态做业务处理 也就是我们需要在多个地方监听同一个状态变化，然后去某个接口取出当前状态做业务处理。 这样的处理重复而不优雅。 突然有一天逛掘金，看到这么一个文章分享: 构建复杂应用的神器，FBroadcast 看完后，脑子里只有一个字: 这就是我想要的神器 虽然它是用dart写给flutter 但没关系，借鉴一下，用typescript重写一下 (ps:部分说明也是复制过来的) 我喜欢逛掘金，虽然他们大多是分享web前端相关的知识，但也有很多可以借鉴用到游戏前端的地方。受益匪浅。 介绍一个基于TypeScript的一套高效灵活的广播系统，可以帮助开发者轻松、有序的构建具有极具复杂性的关联交互和状态变化的游戏和应用。 特性 基础事件机制的支持 消息支持携带任意类型的数据(并有类型提示) 支持函数this绑定或任意类型作为环境，一行代码就可以移除环境内所有的接收者 易于构建局部/全局的状态管理 支持双向通信 支持不可思议的粘性广播 基于TypeScript并提供极度舒适的类型提示 安装/获取 源码获取 12git clone https://github.com/AILHC/EasyGameFrameworkOpen//文件路径：EasyGameFrameworkOpen/packages/broadcast npm 安装 1npm i @ailhc/broadcast 注意⚠️ 如果所在项目不支持直接使用npm包 则需要到dist文件夹下，取出可以使用的模块规范类型的文件 比如CocosCreator3D，支持systemjs规范 则可以拿systemjs文件夹下的文件，复制到项目中，设置为插件就可以引入使用了 使用 通过 broadcast 来注册，发送广播非常简便 123456//注册接收器this._broadcast.on(\"testA\", (str) =&gt; &#123; //do something&#125;)//发送消息this._broadcast.broadcast(\"testA\", \"string\") broadcast允许在注册/发送消息时，携带任意类型数据，并支持类型提示 broadcast允许在注册消息时，给自己透传数据（而非通过闭包取闭包外数据的方式） 灵感来自Laya的EventDispatcher 闭包使用不当容易出问题。 开发者可以选择将特定类型的消息进行持久化，这样就能轻易实现广播式的全局状态管理。 ⚠️注意，一个消息类型一旦持久化就只能通过 brocast.offAll(key) 来从广播系统中移除该类型的消息。 12345678910broadcast.broadcast( //消息类型key \"objTypeTest\", //数据 &#123;a:1,b:\"\",c:false&#125;, //回调 undefined, //持久化 true ) 粘性广播 12345broadcast.stickyBroadcast( //消息类型key \"stringTypeTest\", //数据 \"\"); 当广播系统中没有对应类型的接收器时，粘性广播 将会暂时滞留在系统中，直到有该类型的接收器被注册，则会立即发出广播（当广播系统中有对应类型的接收器时，就和普通广播具有相同的表现）。 双向通信 双向沟通，双倍效率 broadcast支持在广播发送点接收接收器返回的消息。 123456789101112131415161718192021//发送消息broadcast.broadcast( //消息类型key \"numberTypeTest\", //数据 1, ////接收器返回的消息 (data) =&gt; &#123; // do something &#125;)//注册接收器broadcast.on(\"numberTypeTest\", (data, callback) =&gt; &#123; /// do something var result = logic(); // 返回消息 callback(result);&#125;) 支持函数this绑定或任意类型作为 环境绑定 在CocosCreator中注册事件可以这样 1this.node.on(cc.Node.EventType.TOUCH_START, this.showAnimView, this) 这个this可以用来调用showAnimView这个方法，不至于调用的方法里使用this时丢失this 而在broadcast中也支持，还支持在环境解构时，开发者可以方便的一次性移除所有在该环境中注册的接收器。 1broadcast.offAllByContext(this) 支持批量注册接收者 12345678910111213141516171819broadcast.on([ &#123; //消息类型 key: \"numberTypeTest\", //接收器 listener: this.onNumberTypeTest, //环境 context: this &#125;, &#123; //消息类型 key: \"stringTypeTest\", //接收器 listener: this.onStringTypeTest, //环境 context: this &#125; //]) 基本的使用就这些了 具体的使用例子可以克隆仓库:EasyGameFramework 看基于CocosCreator2.4.2的demo examples/egf-ccc-full/assets/tests/broadcastTest 打开这个场景:broadcastTest.fire 看demo之前，需要安装环境哦， 安装 npm ，然后到egf-ccc-full 根目录 1npm install 极度舒适的类型提示演示1234567891011121314151617181920212223242526272829303132//需要消息定义者，定义时添加如下类型声明declare global &#123; interface ITestKey extends broadcast.IMsgKey &#123; testA: \"testA\", testB: \"testB\", testC: \"testC\", testD: \"testD\", //消息类型key提示 objTypeTest: \"objTypeTest\" &#125; interface ITestValueType extends broadcast.IMsgValueType &#123; testA: string, testB: string, testC: string, testD: string, //对应消息类型的发消息和收消息的类型声明 objTypeTest: &#123; a: number, b: string, c: boolean &#125; &#125; interface ITestResultType extends broadcast.IResultType &#123; testC: string, //双向通信返回数据类型声明 objTypeTest: &#123; callbackDataA: &#123; hahah: string &#125; &#125; &#125;&#125;//然后在实例化broadcast时，注入类型export default class TestBroadcast extends cc.Component &#123; private _broadcast: Broadcast&lt;ITestKey, ITestValueType, ITestResultType&gt; start() &#123; this._broadcast = new Broadcast&lt;ITestKey, ITestValueType, ITestResultType&gt;(); &#125;&#125; 演示 demo测试展示 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/categories/EasyGameFramework/"},{"name":"broadcast","slug":"EasyGameFramework/broadcast","permalink":"http://yoursite.com/categories/EasyGameFramework/broadcast/"}],"tags":[{"name":"事件机制","slug":"事件机制","permalink":"http://yoursite.com/tags/事件机制/"},{"name":"事件通信","slug":"事件通信","permalink":"http://yoursite.com/tags/事件通信/"}],"keywords":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/categories/EasyGameFramework/"},{"name":"broadcast","slug":"EasyGameFramework/broadcast","permalink":"http://yoursite.com/categories/EasyGameFramework/broadcast/"}]},{"title":"记第一次参加Cocos开发者沙龙","slug":"记第一次参加Cocos开发者沙龙","date":"2020-12-27T03:26:57.000Z","updated":"2020-12-27T04:32:18.047Z","comments":false,"path":"2020/12/27/记第一次参加Cocos开发者沙龙/","link":"","permalink":"http://yoursite.com/2020/12/27/记第一次参加Cocos开发者沙龙/","excerpt":"","text":"这次的Cocos开发者沙龙，是在广州开的。 我还没参加过这类开发者沙龙，一看到推文立刻报名，心里非常期待。 初印象刚到沙龙地点时，就见到了jare大佬在门外，抽烟。我反复确认了一下，的确是。开心~但没有拍到大佬的照片，可惜了，这里补一张 我上去沙龙所在楼层，由于我来得早，沙龙还没开始 技术分享放空大佬，分享了CocosCreator3.0的全貌以及更强的特性。 还有我全程喊666的 气氛组负责人潘伟洲大佬的分享非常值得学习 高能在线教育解决方案全貌 通信痛点和jsb绑定实现 多协议网络库架构 Cocos游戏内音视频播放解决思路 路由管理的实现(有所启发，到时分享) nb的混合引擎开发其他大佬的分享都非常棒我就不一一列举了 挺好吃的点心我吃了一个椰奶冻，不知道是不是这个名字，用一个玻璃瓶装着，一开始以为是酸奶，打开想喝，却倒不下来。然后去拿了一个叉子。 最后的QA我问了一个我比较关心，也很好奇的问题。因为潘伟洲大佬说，他推动腾讯内部教育相关项目组共建ABCKit这个项目，并打算明年开放。我很好奇：这个ABCKit如何进行共建和维护？(因为我也有框架开源:EasyGameFramework,希望汲取经验)大佬回复说： 请吃饭（一顿不行就两顿），积极推动这个项目的推广和使用，并一起共建。 技术上，内部开源，提供框架源码和例子展示。 非常感谢大佬~ 我也如愿领到了Cocos的十周年纪念品，一件女朋友都说好看的黑色卫衣 各位大佬合照 祝愿祝Cocos发展得更好，走得更远~ 希望下次再来广州下次再见~ 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"经历","slug":"经历","permalink":"http://yoursite.com/categories/经历/"}],"tags":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"},{"name":"开发者沙龙","slug":"开发者沙龙","permalink":"http://yoursite.com/tags/开发者沙龙/"}],"keywords":[{"name":"经历","slug":"经历","permalink":"http://yoursite.com/categories/经历/"}]},{"title":"基于TypeScript的通用游戏UI框架的使用","slug":"基于TypeScript的通用游戏UI框架的使用","date":"2020-12-24T16:56:34.000Z","updated":"2020-12-27T04:25:01.863Z","comments":false,"path":"2020/12/25/基于TypeScript的通用游戏UI框架的使用/","link":"","permalink":"http://yoursite.com/2020/12/25/基于TypeScript的通用游戏UI框架的使用/","excerpt":"","text":"前言之前发了一篇文章分享了我设计和实现这个基于TypeScript的通用游戏UI框架的过程和想法，但没有详细的介绍如何使用。 文章链接:通用游戏UI框架的设计与实现 这次就讲清楚如何使用~ 介绍display-ctrl是一个基于TypeScript的零依赖、跨引擎、高效、灵活、高可扩展的显示控制库(UI框架库) 您可以根据项目，以及项目所使用的引擎，定制资源处理和控制器基类。 合理的抽象底层，让您可以继承管理器基类，使用基类接口就可以简单扩展出符合自身需求的接口。 同时这个库使用了TypeScript的高阶的类型推断，给您带来极度舒适的接口调用体验。 这个库无任何依赖，可单独使用。 在仓库中同时提供了基于CocosCreator2.4.2和CocosCreator3D实现的库(包含layer层级管理库的实现) dpctrl-ccc dpctrl-c3d github:EasyGameFramework 特性 跨引擎，适用于任何适用ts/js的游戏/应用项目 基于TypeScript，使用高阶类型编程，提供极度舒适的类型提示 高可扩展 高可定制 零依赖，可单独使用如何使用？安装 通过npm安装 npm i @ailhc/display-ctrl 本地link npm包 a. clone 项目仓库 git clone https://github.com/AILHC/EasyGameFrameworkOpen b. 在packages/display-ctrl文件夹下 npm link c. 在项目游戏项目目录下 npm link @ailhc/display-ctrl 使用源码 a. clone 项目仓库 git clone https://github.com/AILHC/EasyGameFrameworkOpen b. 直接复制packages/display-ctrl/src下的ts源码到项目文件夹下使用 定制一下实现引擎层 不同的引擎或者项目都需要做点相应的实现，很简单的 控制器基类实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import &#123; &#125; from \"@ailhc/display-ctrl\";export class NodeCtrl implements displayCtrl.ICtrl&lt;cc.Node&gt; &#123; key?: string | any; isLoading?: boolean; isLoaded?: boolean; isInited?: boolean; isShowed?: boolean; needShow?: boolean; needLoad?: boolean; isShowing?: boolean; visible: boolean; onLoadData: any; protected node: cc.Node; protected _mgr: displayCtrl.IMgr; constructor(dpcMgr?: displayCtrl.IMgr) &#123; this._mgr = dpcMgr; &#125; onInit(config?: displayCtrl.IInitConfig&lt;any, any&gt;): void &#123; &#125; onShow(config?: displayCtrl.IShowConfig&lt;any, any, any&gt;): void &#123; if (this.node) &#123; this.node.active = true; &#125; &#125; getRess(): any[] | string[] &#123; return undefined; &#125; getNode(): cc.Node &#123; return this.node; &#125; onUpdate(updateData: any): void &#123; &#125; getFace&lt;T = any&gt;(): T &#123; return this as any; &#125; onDestroy(destroyRes?: boolean): void &#123; if (this.node) &#123; this.node.destroy(); &#125; &#125; onHide() &#123; if (this.node) &#123; this.node.active = false; &#125; &#125; forceHide() &#123; this.node &amp;&amp; (this.node.active = false); this.isShowed = false; &#125; onResize() &#123; &#125;&#125; 我已经提供了两个CocosCreator版本的实现参考 CocosCreator3d的实现dpctrl-c3d CocosCreator2.4.2的实现dpctrl-ccc可以直接安装(同上) 资源处理接口定制每个项目都有自己的资源处理需求，所以这部分逻辑解耦出来，让使用者注入资源处理器。12345678910111213141516171819202122232425262728293031323334353637383940//egf-ccc-full DpcTestMainComp.tsconst dpcMgr = new DpcMgr&lt;IDpcTestViewKeyMap, any, IDpcTestViewShowDataMap&gt;(); dpcMgr.init( &#123; loadRes: (config) =&gt; &#123; const onLoadData: IDpcTestOnLoadData = config.onLoadData; onLoadData?.showLoading &amp;&amp; dtM.uiMgr.showDpc(\"LoadingView\"); cc.assetManager.loadAny(config.ress, &#123; bundle: \"resources\" &#125;, (finish, total) =&gt; &#123; console.log(`$&#123;config.key&#125;加载中:$&#123;finish&#125;/$&#123;total&#125;`); onLoadData?.showLoading &amp;&amp; dtM.uiMgr.updateDpc(\"LoadingView\", &#123; finished: finish, total: total &#125;) &#125;, (err, items) =&gt; &#123; if (err) &#123; console.error(`加载失败`, err); config.error &amp;&amp; config.error(); &#125; else &#123; config.complete &amp;&amp; config.complete(); &#125; onLoadData?.showLoading &amp;&amp; dtM.uiMgr.hideDpc(\"LoadingView\"); &#125;) &#125;, releaseRes: (ctrlIns) =&gt; &#123; const ress = ctrlIns.getRess(); if (ress &amp;&amp; ress.length) &#123; let asset: cc.Asset; ress.forEach((res: &#123; path: string &#125;) =&gt; &#123; asset = cc.resources.get(res.path); if (asset) &#123; cc.assetManager.releaseAsset(asset); &#125; &#125;); &#125; &#125; &#125; ) 开始使用基础使用（以CocosCreator2.4.2为例):创建一个普通的界面 创建一个简单的界面的prefab在测试场景，新建一个node节点，放点图片，spine动画什么的。 然后拖到resources/display-ctrl-test-views下 删掉场景中的界面节点 新建一个界面控制器代码文件123456789101112131415161718192021222324252627282930313233343536373839404142// DepResView.ts// 增加界面key声明，为了调用显示接口时有类型提示declare global &#123; interface IDpcTestViewKeyMap &#123; DepResView: \"DepResView\" &#125;&#125;export class DepResView extends NodeCtrl &#123; static typeKey = \"DepResView\"; private static _ress: &#123; path: string, type: any &#125;[]; //界面prefab资源路径 public static prefabUrl = \"display-ctrl-test-views/DepResView\"; onLoadData: IDpcTestOnLoadData = &#123; showLoading: true &#125;; //实现getRess接口返回依赖资源数组 getRess() &#123; if (!DepResView._ress) &#123; DepResView._ress = [ &#123; path: DepResView.prefabUrl, type: cc.Prefab &#125;, &#123; path: \"test-txts/txt1\", type: cc.TextAsset &#125; ] &#125; return DepResView._ress; &#125; //实现onInit接口，实例化显示节点 onInit() &#123; super.onInit() this.node = getPrefabNodeByPath(DepResView.prefabUrl); this.node.getChildByName(\"close-icon\").on(cc.Node.EventType.MOUSE_DOWN, () =&gt; &#123; dtM.uiMgr.hideDpc(this.key); &#125;) &#125; //实现onShow接口，添加显示节点到Canvas(最好是使用层级管理，比如我框架提供的layer层级管理库) onShow(config: displayCtrl.IShowConfig) &#123; super.onShow(config); const canvas = cc.director.getScene().getChildByName(\"Canvas\"); canvas.addChild(this.node); &#125; onHide() &#123; super.onHide(); &#125;&#125; 来一串基本操作:调用管理器接口 显示12345//简单调用显示dtM.uiMgr.showDpc(\"DepResView\");//打出双引号就有类型提示了//传数据调用显示dtM.uiMgr.showDpc(\"MutiInsView\",onShowData);//打出双引号就有类型提示了 所传数据也有类型提示，需要在任意地方声明（最好是在对应的控制器代码文件中声明）这里以MutiInsView为例，具体可见:examples\\egf-ccc-full\\assets\\tests\\display-ctrl\\view-ctrls\\MutiInsView.ts12345678declare global &#123; interface IDpcTestViewKeyMap &#123; MutiInsView: \"MutiInsView\" &#125; interface IDpcTestViewShowDataMap &#123; MutiInsView: &#123; preStr: string, clickCount: number &#125;; &#125;&#125; 更新当业务需要使用数据让指定界面更新渲染时调用,以加载界面为例1234//开始加载dtM.uiMgr.updateDpc(\"LoadingView\", &#123; finished: 0, total: 1 &#125;);//加载结束dtM.uiMgr.updateDpc(\"LoadingView\", &#123; finished: 1, total: 1 &#125;); 这个更新所传的数据也可以有类型提示,详情可见:examples\\egf-ccc-full\\assets\\tests\\display-ctrl\\view-ctrls\\MutiInsView.ts12345678declare global &#123; interface IDpcTestViewKeyMap &#123; LoadingView: \"LoadingView\" &#125; interface IDpcTestUpdateDataMap &#123; LoadingView: &#123; finished: number, total: number &#125; &#125;&#125; 隐藏 1dtM.uiMgr.hideDpc(\"DepResView\");//打出双引号就有类型提示了 销毁 1dtM.uiMgr.destroyDpc(dtM.uiMgr.keys.DepResView, true);//第二个参数可以选择是否销毁资源 自定义资源处理显示控制器 在业务开发中，可能有些界面的资源处理逻辑特殊，需要自定义，框架提供了自定义资源处理的接口 创建一个自定义资源处理显示控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243//需要继承displayCtrl.IResHandler,管理器会调用控制器实现的这个接口而不是通用处理器的接口export class CustomResHandleView extends NodeCtrl implements displayCtrl.IResHandler &#123; static typeKey = \"CustomResHandleView\"; private static _ress: string[]; private static _monsterNames = [\"BuleMonster\", \"GreenMonster\", \"PurpleMonster\", \"RedMonster\", \"YellowMonster\"]; private static _monsterIconDir = \"monster_icon\"; private static prefabUrl: string = \"display-ctrl-test-views/CustomResHandleView\"; private _monsterIconRess: &#123; path: string, type: any &#125;[]; //自定义资源加载 loadRes(config: displayCtrl.IResLoadConfig): void &#123; dtM.uiMgr.showDpc(&#123; typeKey: dtM.uiMgr.keys.LoadingView, showedCb: () =&gt; &#123; const randomMonsterNameIndexs = getSomeRandomInt(0, CustomResHandleView._monsterNames.length - 1, 2); const ress = []; this._monsterIconRess = ress; randomMonsterNameIndexs.forEach(element =&gt; &#123; ress.push(&#123; path: CustomResHandleView._monsterIconDir + \"/\" + CustomResHandleView._monsterNames[element], type: cc.SpriteFrame &#125;); &#125;); ress.push(&#123; path: CustomResHandleView.prefabUrl, type: cc.Prefab &#125;); ress.push(&#123; path: \"test-txts/txt1\", type: cc.TextAsset &#125;); cc.assetManager.loadAny(ress, &#123; bundle: \"resources\" &#125;, (finished: number, total: number, item) =&gt; &#123; dtM.uiMgr.updateDpc(dtM.uiMgr.keys.LoadingView, &#123; finished: finished, total: total &#125;) &#125;, (err, data) =&gt; &#123; if (err) &#123; config.error(); &#125; else &#123; config.complete(); &#125; dtM.uiMgr.hideDpc(\"LoadingView\"); &#125;); &#125; &#125;) &#125; //自定义资源释放 releaseRes(): void &#123; cc.assetManager.releaseAsset(cc.resources.get(CustomResHandleView.prefabUrl)); &#125; //省略代码&#125; 管理器的其他接口 具体的接口声明可以看:dp-ctrl-interfaces.ts 中的IMgr 获取依赖资源,可用于获取多个控制器依赖的资源，批量预加载 获取单例控制器实例 预加载指定控制器 创建控制器实例等等 其他可能性其实游戏主角也可以是显示控制器实例 通过IShowConfig定制更多可能性，比如页面显示动画播放完回调 利用管理器的基础接口扩展出管理栈式UI的逻辑 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"EasyGameFramework使用","slug":"EasyGameFramework使用","permalink":"http://yoursite.com/categories/EasyGameFramework使用/"},{"name":"display-ctrl","slug":"EasyGameFramework使用/display-ctrl","permalink":"http://yoursite.com/categories/EasyGameFramework使用/display-ctrl/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"}],"keywords":[{"name":"EasyGameFramework使用","slug":"EasyGameFramework使用","permalink":"http://yoursite.com/categories/EasyGameFramework使用/"},{"name":"display-ctrl","slug":"EasyGameFramework使用/display-ctrl","permalink":"http://yoursite.com/categories/EasyGameFramework使用/display-ctrl/"}]},{"title":"解决CocosCreator2.4.x的ABundle不能使用npm包的问题","slug":"解决CocosCreator2-4-x的ABundle不能使用npm包的问题","date":"2020-12-24T15:34:39.000Z","updated":"2020-12-24T16:57:33.285Z","comments":false,"path":"2020/12/24/解决CocosCreator2-4-x的ABundle不能使用npm包的问题/","link":"","permalink":"http://yoursite.com/2020/12/24/解决CocosCreator2-4-x的ABundle不能使用npm包的问题/","excerpt":"","text":"前言今天逛论坛时，我看论坛上有个小伙伴问cocoscreator能不能用npm包？ 帖子:cocos creator 工程里面能装npm包吗？ 我在想怎么可能不支持呢? 于是点击去看到了大佬的回答，也仔细看了大佬写的了一篇AssetBundle的讲解文章 Creator | Asset Bundle 全解析 这里说npm包都打进了main这个bundle了，分包里没法引用 这句话让我不禁想了一下，EasyGameFramework的所有库都是以npm包的方式安装使用的。 如果不能在分包引用，那不就很烦？ 我用egf-ccc-full的项目做了一个测试，发现预览可以，构建出来真的不行，加载bundle就直接报错了。 后来我尝试挂载到全局，可以正常运行，但编码体验下降一百倍，过程繁琐。 我忍不了了 之前就发现一个跟npm包相关的问题：不支持引用项目文件夹外的npm包，编辑器编辑和构建会报错（但预览不会）那个问题我已经解决了:CocosCreator2.4.2/2.4.3无法编译引用了项目文件夹外部的npm模块 所以我觉得这两个问题应该是差不多的。 今天我就让ABundle支持引用npm包！！！ @一下引擎组 问题重要吗?我觉得很重要! 虽然说可以将npm包的东西挂载到全局，然后在分包里的脚本，去全局取用。 但这样不安全。控制台也可以访问到了。 而且最重要的是，很别扭，你知道吧？这编码体验很不爽了。 EasyGameFramework的出发点就是要让编码更加Easy，更加爽。 所以今天我就让ABundle支持引用npm包！！！今天我就让ABundle支持引用npm包！！！让EasyGameFramework无缝支持分包使用 复现问题flag已经立了，说明我已经解决了。哈哈哈哈哈哈~ 它不可能倒下的~ 我们先把问题复现出来，看看是怎么回事。 只有构建之后才能看出问题，所以先构建一波，这里我使用egf-ccc-full来测试。 https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/examples/egf-ccc-full 大家可以克隆下来看看 我简单讲一下我的测试逻辑 加载abtest这个包：test/display-ctrl/abtest，然后将这个包里的ABTestModule注入模块管理器 通过abtest模块的逻辑，显示abtest里的界面 ABTestModule注入全局 ABTestView继承@ailhc/dpctrl-ccc包的NodeCtrl运行构建后的看看报错找不到模块，这个报错的模块名有点奇怪啊，不是我的包名@ailhc/dpctrl-ccc,被切了万能的断点调试 我们会发现，在分包的index.js找不到，只有两个包内的脚本模块对象 下一步。 然后它把包名切割了！！！！就这样就切割了？？？！！！为什么？ 给不懂的科普一下npm包名 · npm包名是没有./或者../的，大多是只有一个名字 比如xstate · 有一些特殊的包名比如:@babel/core，比如@ailhc/egf-core 继续跟踪，它进了一个require函数，然后跳转过去，发现这个index.js是main bundle里的通过切割后的名字dpctrl-ccc到main包里也没找到其实main包里应该是有这个包的，只是key不对。我通过调试main index.js中对@ailhc/dpctrl-ccc的引用其实是可以找到的，只是它的key 转化为4 调试总结通过这系列调试，我们可以知道 主包main里的index.js有npm包模块，也可以引用 分包里的index.js如果引用了包外的脚本模块，则会向上main包查找，查不到就报错 而这个分包向主包查找模块的逻辑里，没考虑到npm包名的情况 主包和分包里的index.js的开头那部分都很像，像是模板 总结完之后，我们就去根据我们调试的成果去尝试解决问题 如何来解决这个问题呢？首先得找到模板index.js开头通过进入编辑器目录，搜索文本__require找到了CocosDashboard\\resources.editors\\Creator\\2.4.2\\resources\\static_prelude.js12345678910111213141516171819202122232425262728(function e(t, n, r) &#123; function s(o, u) &#123; if (!n[o]) &#123; if (!t[o]) &#123; var b = o.split('/'); b = b[b.length - 1]; if (!t[b]) &#123; var a = \"function\" == typeof __require &amp;&amp; __require; if (!u &amp;&amp; a) return a(b, !0); if (i) return i(b, !0); throw new Error(\"Cannot find module '\" + o + \"'\"); &#125; o = b; &#125; var f = n[o] = &#123; exports: &#123;&#125; &#125;; t[o][0].call(f.exports, function (e) &#123; var n = t[o][1][e]; return s(n || e); &#125;, f, f.exports, e, t, n, r); &#125; return n[o].exports; &#125; var i = \"function\" == typeof __require &amp;&amp; __require; for (var o = 0; o &lt; r.length; o++) s(r[o]); return s;&#125;) 很像啊哈 简直就是🙄 然后我简单的加了一句log，发现重新构建之后输出出来了，说明改这个有效 然后呢，解决那个切掉我npm包名的逻辑先判断路径是什么类型的，再决定切不切 12345678var b = o;if (o.includes(\"./\")) &#123;//内部代码b = o.split(\"/\");b = b[b.length - 1];&#125; else &#123; //npm包代码&#125; 最后呢，因为主包中，npm包包名和模块对象的对应关系被转换了所以呢 我们在第一次引用的时候，判断是不是npm包，如果是，就以包名为key，记录一下，下次好用包名查找 123456789101112131415161718192021222324252627282930313233343536373839(function e(t, n, r) &#123; function s(o, u, npmPkgName) &#123; if (!n[o]) &#123; if (!t[o]) &#123; var b = o; if (o.includes(\"./\")) &#123; //内部代码 b = o.split(\"/\"); b = b[b.length - 1]; &#125; else &#123; //npm包代码 &#125; if (!t[b]) &#123; var a = \"function\" == typeof __require &amp;&amp; __require; if (!u &amp;&amp; a) return a(b, !0); if (i) return i(b, !0); throw new Error(\"Cannot find module '\" + o + \"'\"); &#125; o = b; &#125; var f = n[o] = &#123; exports: &#123;&#125; &#125;; t[o][0].call(f.exports, function (e) &#123; var n = t[o][1][e]; //判断是不是npm包，是就传包名 return s(n || e, undefined, !e.includes(\"./\") ? e : undefined); &#125;, f, f.exports, e, t, n, r); &#125; //判断是不是npm包，是就用包名作为key存一下模块引用 if (npmPkgName &amp;&amp; n[o] &amp;&amp; !n[npmPkgName]) &#123; n[npmPkgName] = n[o]; &#125; return n[o].exports; &#125; var i = \"function\" == typeof __require &amp;&amp; __require; for (var o = 0; o &lt; r.length; o++) s(r[o]); return s;&#125;) 重新构建，运行，没有报错~搞定散花~ 重要提示虽然说搞定了，但它还是有局限性的 比如，你主包没有引用过npm包，那么你分包也引用不了 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/categories/CocosCreator/"},{"name":"EasyGameFramework使用","slug":"CocosCreator/EasyGameFramework使用","permalink":"http://yoursite.com/categories/CocosCreator/EasyGameFramework使用/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"}],"keywords":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/categories/CocosCreator/"},{"name":"EasyGameFramework使用","slug":"CocosCreator/EasyGameFramework使用","permalink":"http://yoursite.com/categories/CocosCreator/EasyGameFramework使用/"}]},{"title":"解决CocosCreator2.4.x的ABundle不能使用npm包的问题","slug":"Fix-the-problem-with-the-NPM-package-not-available-in-the-ABundle-of-Cocoscreator2-4-x","date":"2020-12-21T12:00:09.000Z","updated":"2020-12-25T00:15:19.522Z","comments":false,"path":"2020/12/21/Fix-the-problem-with-the-NPM-package-not-available-in-the-ABundle-of-Cocoscreator2-4-x/","link":"","permalink":"http://yoursite.com/2020/12/21/Fix-the-problem-with-the-NPM-package-not-available-in-the-ABundle-of-Cocoscreator2-4-x/","excerpt":"","text":"前言今天逛论坛时，我看论坛上有个小伙伴问cocoscreator能不能用npm包？ 帖子:cocos creator 工程里面能装npm包吗？ 我在想怎么可能不支持呢? 于是点击去看到了大佬的回答，也仔细看了大佬写的了一篇AssetBundle的讲解文章 Creator | Asset Bundle 全解析 这里说npm包都打进了main这个bundle了，分包里没法引用 这句话让我不禁想了一下，EasyGameFramework的所有库都是以npm包的方式安装使用的。 如果不能在分包引用，那不就很烦？ 我用egf-ccc-full的项目做了一个测试，发现预览可以，构建出来真的不行，加载bundle就直接报错了。 后来我尝试挂载到全局，可以正常运行，但编码体验下降一百倍，过程繁琐。 我忍不了了 之前就发现一个跟npm包相关的问题：不支持引用项目文件夹外的npm包，编辑器编辑和构建会报错（但预览不会）那个问题我已经解决了:CocosCreator2.4.2/2.4.3无法编译引用了项目文件夹外部的npm模块 所以我觉得这两个问题应该是差不多的。 今天我就让ABundle支持引用npm包！！！ @一下引擎组 问题重要吗?我觉得很重要! 虽然说可以将npm包的东西挂载到全局，然后在分包里的脚本，去全局取用。 但这样不安全。控制台也可以访问到了。 而且最重要的是，很别扭，你知道吧？这编码体验很不爽了。 EasyGameFramework的出发点就是要让编码更加Easy，更加爽。 所以今天我就让ABundle支持引用npm包！！！今天我就让ABundle支持引用npm包！！！让EasyGameFramework无缝支持分包使用 复现问题flag已经立了，说明我已经解决了。哈哈哈哈哈哈~ 它不可能倒下的~ 我们先把问题复现出来，看看是怎么回事。 只有构建之后才能看出问题，所以先构建一波，这里我使用egf-ccc-full来测试。 https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/examples/egf-ccc-full 大家可以克隆下来看看 我简单讲一下我的测试逻辑 加载abtest这个包：test/display-ctrl/abtest，然后将这个包里的ABTestModule注入模块管理器 通过abtest模块的逻辑，显示abtest里的界面 ABTestModule注入全局 ABTestView继承@ailhc/dpctrl-ccc包的NodeCtrl运行构建后的看看报错找不到模块，这个报错的模块名有点奇怪啊，不是我的包名@ailhc/dpctrl-ccc,被切了万能的断点调试 我们会发现，在分包的index.js找不到，只有两个包内的脚本模块对象 下一步。 然后它把包名切割了！！！！就这样就切割了？？？！！！为什么？ 给不懂的科普一下npm包名 · npm包名是没有./或者../的，大多是只有一个名字 比如xstate · 有一些特殊的包名比如:@babel/core，比如@ailhc/egf-core 继续跟踪，它进了一个require函数，然后跳转过去，发现这个index.js是main bundle里的通过切割后的名字dpctrl-ccc到main包里也没找到其实main包里应该是有这个包的，只是key不对。我通过调试main index.js中对@ailhc/dpctrl-ccc的引用其实是可以找到的，只是它的key 转化为4 调试总结通过这系列调试，我们可以知道 主包main里的index.js有npm包模块，也可以引用 分包里的index.js如果引用了包外的脚本模块，则会向上main包查找，查不到就报错 而这个分包向主包查找模块的逻辑里，没考虑到npm包名的情况 主包和分包里的index.js的开头那部分都很像，像是模板 总结完之后，我们就去根据我们调试的成果去尝试解决问题 如何来解决这个问题呢？首先得找到模板index.js开头通过进入编辑器目录，搜索文本__require找到了CocosDashboard\\resources.editors\\Creator\\2.4.2\\resources\\static_prelude.js12345678910111213141516171819202122232425262728(function e(t, n, r) &#123; function s(o, u) &#123; if (!n[o]) &#123; if (!t[o]) &#123; var b = o.split('/'); b = b[b.length - 1]; if (!t[b]) &#123; var a = \"function\" == typeof __require &amp;&amp; __require; if (!u &amp;&amp; a) return a(b, !0); if (i) return i(b, !0); throw new Error(\"Cannot find module '\" + o + \"'\"); &#125; o = b; &#125; var f = n[o] = &#123; exports: &#123;&#125; &#125;; t[o][0].call(f.exports, function (e) &#123; var n = t[o][1][e]; return s(n || e); &#125;, f, f.exports, e, t, n, r); &#125; return n[o].exports; &#125; var i = \"function\" == typeof __require &amp;&amp; __require; for (var o = 0; o &lt; r.length; o++) s(r[o]); return s;&#125;) 很像啊哈 简直就是🙄 然后我简单的加了一句log，发现重新构建之后输出出来了，说明改这个有效 然后呢，解决那个切掉我npm包名的逻辑先判断路径是什么类型的，再决定切不切 12345678var b = o;if (o.includes(\"./\")) &#123;//内部代码b = o.split(\"/\");b = b[b.length - 1];&#125; else &#123; //npm包代码&#125; 最后呢，因为主包中，npm包包名和模块对象的对应关系被转换了所以呢 我们在第一次引用的时候，判断是不是npm包，如果是，就以包名为key，记录一下，下次好用包名查找 123456789101112131415161718192021222324252627282930313233343536373839(function e(t, n, r) &#123; function s(o, u, npmPkgName) &#123; if (!n[o]) &#123; if (!t[o]) &#123; var b = o; if (o.includes(\"./\")) &#123; //内部代码 b = o.split(\"/\"); b = b[b.length - 1]; &#125; else &#123; //npm包代码 &#125; if (!t[b]) &#123; var a = \"function\" == typeof __require &amp;&amp; __require; if (!u &amp;&amp; a) return a(b, !0); if (i) return i(b, !0); throw new Error(\"Cannot find module '\" + o + \"'\"); &#125; o = b; &#125; var f = n[o] = &#123; exports: &#123;&#125; &#125;; t[o][0].call(f.exports, function (e) &#123; var n = t[o][1][e]; //判断是不是npm包，是就传包名 return s(n || e, undefined, !e.includes(\"./\") ? e : undefined); &#125;, f, f.exports, e, t, n, r); &#125; //判断是不是npm包，是就用包名作为key存一下模块引用 if (npmPkgName &amp;&amp; n[o] &amp;&amp; !n[npmPkgName]) &#123; n[npmPkgName] = n[o]; &#125; return n[o].exports; &#125; var i = \"function\" == typeof __require &amp;&amp; __require; for (var o = 0; o &lt; r.length; o++) s(r[o]); return s;&#125;) 重新构建，运行，没有报错~搞定散花~ 重要提示虽然说搞定了，但它还是有局限性的 比如，你主包没有引用过npm包，那么你分包也引用不了 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"EasyGameFramework使用","slug":"EasyGameFramework使用","permalink":"http://yoursite.com/categories/EasyGameFramework使用/"},{"name":"CocosCreator","slug":"EasyGameFramework使用/CocosCreator","permalink":"http://yoursite.com/categories/EasyGameFramework使用/CocosCreator/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"}],"keywords":[{"name":"EasyGameFramework使用","slug":"EasyGameFramework使用","permalink":"http://yoursite.com/categories/EasyGameFramework使用/"},{"name":"CocosCreator","slug":"EasyGameFramework使用/CocosCreator","permalink":"http://yoursite.com/categories/EasyGameFramework使用/CocosCreator/"}]},{"title":"通用游戏UI框架的设计与实现","slug":"Design-and-implementation-of-a-general-game-display-management-framework","date":"2020-12-19T14:06:23.000Z","updated":"2020-12-20T04:44:12.403Z","comments":true,"path":"2020/12/19/Design-and-implementation-of-a-general-game-display-management-framework/","link":"","permalink":"http://yoursite.com/2020/12/19/Design-and-implementation-of-a-general-game-display-management-framework/","excerpt":"","text":"@TOC 前言这个月月初，我发了几篇文章分享了我写框架的心路历程和一些自己的想法。感兴趣的可以通过文末链接回顾。 同时我发布了我的第一个开源渐进式H5游戏开发框架: EasyGameFrameworkOpen 提供强大轻量级的核心库:模块管理库 @ailhc/egf-core。可以无缝接入任意引擎游戏项目 以及提供一个基于rollup的typescript库构建工具: @ailhc/egf-cli，可以构建出适合任意引擎项目的js库和单一.d.ts声明文件 类似cocos.d.ts声明文件。 在之前的文章中，我也预告了，还有后续的分享。后续的分享也是关于框架其他库的设计与实现的。 虽然文章还没出，但一直在更新。 大家可以关注框架的github仓库，如果可以，给个star哦。 为什么鸽了这么久才更新呢？本来预期是上个星期更新的。 但是涅~(￣▽￣)~* 首先工作比较忙，家里又有事情需要处理 同时，接下来要讲的这个方面我觉得比较难，我想要讲清楚讲明白(原谅我稚嫩的笔触) 我想添加尽可能多的单元测试和demo例子(毕竟要往更加规范的工程化靠拢) 鸽子🕊 : 别哔哔，鸽了就是鸽了，赶紧进入正题~ 我: 好嘞~ 背景做游戏，绝大部分，UI交互界面是必不可少的。 当项目的UI界面多起来的时候，而且策划们的需求千奇百怪，迭代频繁的时候，就会让我们非常头疼。 接下来我将以我稚嫩的笔触分享我是如何分析和解决这个头疼问题的。 这个议题偏向主观和开放，每个人都有自己的业务开发经历和想法，而我就在此抛砖引玉，献丑了。 如有不足，请各位多多指教🙏( •̀ ω •́ )✧ 本质需求我们来看两种情景 策划提了一个需求:一个有五彩斑斓的黑背景的文本提示界面B-&gt;程序员去实现界面B的逻辑 点击A按钮-&gt;显示B界面 这两个情景就是我们开发中最最最常见，最最最本质的两个需求： 实现UI界面逻辑 调用界面 那么我们头疼也就是这两个需求的实现，我分别讲一下 UI逻辑的实现UI逻辑的实现是各种各样，需求也是千奇百怪。 而且这个实现可能不是一步就位的，可能还需要迭代，重做等。 那么在这种情况下，我作为UI逻辑的开发者，我希望 不用关注别的业务逻辑在什么地方怎么调用我，只需要通过告诉外界如何调用我 拥有足够高的自由度 我不一定要加载prefab，我希望可以加载一个图片来动态new一个node来添加组件显示 也不一定要实例化prefab，作为显示节点，我希望可以通过绘图api自己画界面显示 我不一定要用cocoscreator的显示渲染，我希望可以通过写html显示，可以接fgui显示，可以调用安卓和ios的原生界面显示 我不一定使用通用的加载释放逻辑，我希望可以自定义加载和资源释放逻辑 可以自己控制节点添加到那个父节点。 可以依赖多个不同类型的资源，动态生成 在不改变函数接口的情况下，拥有足够高的扩展性 这样高可扩展，高自由度，对外界透明可以让开发者更加专注高效地实现和迭代UI逻辑。 不用因为别人调用不规范导致出bug而头疼 不用因为束手束脚而头疼 不用为想扩展又不想改接口而头疼 UI的调用我们在项目开发中可能会有各种UI调用的需求： UI调用最复杂也是最常用的是显示调用，比如 显示A界面 显示B界面并按照B界面的显示数据接口传递数据给B界面，B按照传递的数据渲染，甚至传递各种回调 显示C界面，想C显示接口调用后回调显示完成回调，即想在界面显示完成后执行逻辑 其他常用的是 更新 隐藏 销毁 还有一些特殊的比如：预加载指定界面（不显示），获取指定界面依赖的资源（用于批量加载多个界面依赖的资源） 除了对功能的需求，还有对接口扩展性的需求 因为在不同项目中，或者不同项目阶段中，可能会增加一些需求，需要扩展接口参数的。但如果接口参数太多，调用就可能会很长很麻烦。 所以会希望，接口有更强的扩展性，而且在不改动底层的情况增加接口就能实现需求。 回头一看好像是自己给自己挖坑啊。不过造轮子的，不都是自己找坑挖坑吗？ 分析完需求，我们就可以着手去设计接口了 接口设计一个简单的流程图 再看一张UML图 UI控制器的接口设计UI控制器的职责就是：实现UI逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 /** * 显示配置 */interface IShowConfig&lt; TypeKey extends keyof any = any, InitDataTypeMapType = any, ShowDataTypeMapType = any, &gt; &#123; typeKey?: TypeKey, /** * 透传初始化数据 */ onInitData?: InitDataTypeMapType[ToAnyIndexKey&lt;TypeKey, InitDataTypeMapType&gt;] /** * 强制重新加载 */ forceLoad?: boolean /** * 显示数据 */ onShowData?: ShowDataTypeMapType[ToAnyIndexKey&lt;TypeKey, ShowDataTypeMapType&gt;], /**在调用控制器实例onShow后回调 */ showedCb?: CtrlInsCb; /**控制器显示完成后回调 */ showEndCb?: VoidFunction; /**显示被取消了 */ onCancel?: VoidFunction, /**加载后onLoad参数 */ onLoadData?: any, /**加载完成回调,返回实例为空则加载失败，返回实例则成功 */ loadCb?: CtrlInsCb&#125;interface ICtrl&lt;NodeType = any&gt; &#123; key?: string | any; /**正在加载 */ isLoading?: boolean; /**已经加载 */ isLoaded?: boolean; /**已经初始化 */ isInited?: boolean; /**已经显示 */ isShowed?: boolean; /**需要显示 */ needShow?: boolean /**需要加载 */ needLoad?: boolean /**正在显示 */ isShowing?: boolean /** * 透传给加载处理的数据, * 会和调用显示接口showDpc中传来的onLoadData合并, * 以接口传入的为主 * Object.assign(ins.onLoadData,cfg.onLoadData); * */ onLoadData?: any; /**获取资源 */ getRess?(): string[] | any[]; /** * 初始化 * @param initData 初始化数据 */ onInit(config?: displayCtrl.IInitConfig): void; /** * 当显示时 * @param showData 显示数据 */ onShow(config?: displayCtrl.IShowConfig): void; /** * 当更新时 * @param updateData 更新数据 * @param endCb 结束回调 */ onUpdate(updateData: any): void; /** * 获取控制器 */ getFace&lt;T&gt;(): ReturnCtrlType&lt;T&gt;; /** * 当隐藏时 */ onHide(): void; /** * 强制隐藏 */ forceHide(): void; /** * 当销毁时 * @param destroyRes */ onDestroy(destroyRes?: boolean): void; /** * 获取显示节点 */ getNode(): NodeType;&#125; 这个接口不依赖任何引擎的接口和类。每个引擎项目实现对应的基类 管理器和业务不需要关注UI逻辑是怎么实现的，只需要调用接口并按照对外的数据接口传数据对象就可以了 onLoadData 这个是通用加载透传数据，比如：告诉通用加载逻辑显示什么加载等待界面 初始化接口onInit ，主要是用于实例化显示节点，监听UI交互事件等 显示接口onShow，主要是将UI显示并根据传入的数据进行渲染用 更新接口onUpdate，主要是根据传入的数据进行渲染更新 获取资源依赖接口 getRess，主要是通用资源处理逻辑需要获取UI界面依赖的资源信息进行加载/释放 其他的接口就很简单了，省略我重点讲一下，onShow这个接口的设计第一版的设计是1234/** * @param onShowData 调用时的透传数据 */onShow(onShowData?:any): void; 这样的设计，只能实现自定义透传显示数据的，但是要想实现管理逻辑的扩展而不改动onShow接口，就会非常麻烦 比如：我想扩展管理器，给UI控制传一个显示完成的回调：派发UI显示完成事件，让UI逻辑中动画播放完，或者其他延迟操作结束后调用。 那按照第一版的设计，那么只能加个参数：onShow(onShowData?:any,showEnd?:VoidFunction) 这个时候就是得修改ICtrl这个接口设计了。一个还可以，那如果变成了两个三个四个参数呢？就会变得复杂。现在的设计就可以解决这个问题，扩展透传的config参数的接口,不会增加接口参数，不改变接口 这个灵感来自axios这个库,一个易用、简洁且高效的http库 关于自定义资源处理实现 有自定义资源处理需求的UI控制器，需要实现这个接口123456789101112131415/** * 资源处理器 */interface IResHandler &#123; /** * 加载资源 * @param config */ loadRes?(config: displayCtrl.IResLoadConfig): void; /** * 释放资源 * @param ctrlIns */ releaseRes?(ctrlIns?: ICtrl): void;&#125; 那么管理器就会调用这个自定义的资源处理接口，而不是走通用的资源处理了 这样的接口设计可以说是在UI被管理的同时，给予了UI逻辑实现者极大的自由度，可以专注高效地实现和迭代，以及任意扩展 极大的自由度是有代价的，就是不能开箱即用。需要去实现接口，其实也很简单，所以这个是值得的。 具体的demo示例可以看:egf-ccc-full中的实现 继续讲UI管理器的设计 UI管理器的设计UI 管理器的职责就是:提供接口让业务去调用UI123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166interface IMgr&lt; CtrlKeyMapType = any, InitDataTypeMapType = any, ShowDataTypeMapType = any, UpdateDataTypeMapType = any&gt; &#123; /**控制器key字典 */ keys: CtrlKeyMapType; /** * 控制器单例字典 */ sigCtrlCache: CtrlInsMap; /** * 初始化 * @param resHandler 资源处理 */ init(resHandler?: IResHandler): void; /** * 批量注册控制器类 * @param classMap */ registTypes(classes: CtrlClassMap | CtrlClassType[]): void; /** * 注册控制器类 * @param ctrlClass * @param typeKey 如果ctrlClass这个类里没有静态属性typeKey则取传入的typeKey */ regist(ctrlClass: CtrlClassType, typeKey?: keyof CtrlKeyMapType): void; /** * 是否注册了 * @param typeKey */ isRegisted&lt;keyType extends keyof CtrlKeyMapType&gt;(typeKey: keyType): boolean; /** * 获取注册类的资源信息 * 读取类的静态变量 ress * @param typeKey */ getDpcRessInClass&lt;keyType extends keyof CtrlKeyMapType&gt;(typeKey: keyType): string[] | any[] /** * 获取单例UI的资源数组 * @param typeKey */ getSigDpcRess&lt;keyType extends keyof CtrlKeyMapType&gt;(typeKey: keyType): string[] | any[]; /** * 获取/生成单例显示控制器示例 * @param typeKey 类型key */ getSigDpcIns&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;(typeKey: keyType): displayCtrl.ReturnCtrlType&lt;T&gt; /** * 加载Dpc * @param typeKey 注册时的typeKey * @param loadCfg 透传数据和回调 */ loadSigDpc&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;(typeKey: keyType, loadCfg?: displayCtrl.ILoadConfig): displayCtrl.ReturnCtrlType&lt;T&gt;; /** * 初始化显示控制器 * @param typeKey 注册类时的 typeKey * @param initCfg displayCtrl.IInitConfig */ initSigDpc&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;( typeKey: keyType, initCfg?: displayCtrl.IInitConfig&lt;keyType, InitDataTypeMapType&gt; ): displayCtrl.ReturnCtrlType&lt;T&gt;; /** * 显示单例显示控制器 * @param typeKey 类key或者显示配置IShowConfig * @param onShowData 显示透传数据 * @param showedCb 显示完成回调(onShow调用之后) * @param onInitData 初始化透传数据 * @param forceLoad 是否强制重新加载 * @param onCancel 当取消显示时 */ showDpc&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;( typeKey: keyType | displayCtrl.IShowConfig&lt;keyType, InitDataTypeMapType, ShowDataTypeMapType&gt;, onShowData?: ShowDataTypeMapType[displayCtrl.ToAnyIndexKey&lt;keyType, ShowDataTypeMapType&gt;], showedCb?: displayCtrl.CtrlInsCb&lt;T&gt;, onInitData?: InitDataTypeMapType[displayCtrl.ToAnyIndexKey&lt;keyType, InitDataTypeMapType&gt;], forceLoad?: boolean, onLoadData?: any, loadCb?: displayCtrl.CtrlInsCb, onCancel?: VoidFunction ): displayCtrl.ReturnCtrlType&lt;T&gt;; /** * 更新控制器 * @param key UIkey * @param updateData 更新数据 */ updateDpc&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType, updateData?: UpdateDataTypeMapType[ToAnyIndexKey&lt;keyType, UpdateDataTypeMapType&gt;]): void; /** * 隐藏单例控制器 * @param key */ hideDpc&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): void; /** * 销毁单例控制器 * @param key * @param destroyRes 销毁资源 */ destroyDpc&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType, destroyRes?: boolean): void; /** * 实例化显示控制器 * @param typeKey 类型key */ insDpc&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;(typeKey: keyType): ReturnCtrlType&lt;T&gt;; /** * 加载显示控制器 * @param ins * @param loadCfg */ loadDpcByIns(ins: displayCtrl.ICtrl, loadCfg?: ILoadConfig): void; /** * 初始化显示控制器 * @param ins * @param initData */ initDpcByIns&lt;keyType extends keyof CtrlKeyMapType&gt;( ins: displayCtrl.ICtrl, initCfg?: displayCtrl.IInitConfig&lt;keyType, InitDataTypeMapType&gt;): void /** * 显示 显示控制器 * @param ins * @param showCfg */ showDpcByIns&lt;keyType extends keyof CtrlKeyMapType&gt;( ins: displayCtrl.ICtrl, showCfg?: displayCtrl.IShowConfig&lt;keyType, InitDataTypeMapType, ShowDataTypeMapType&gt; ): void; /** * 通过实例隐藏 * @param ins */ hideDpcByIns&lt;T extends displayCtrl.ICtrl&gt;(ins: T): void; /** * 通过实例销毁 * @param ins * @param destroyRes 是否销毁资源 */ destroyDpcByIns&lt;T extends displayCtrl.ICtrl&gt;(ins: T, destroyRes?: boolean, endCb?: VoidFunction): void; /** * 获取单例控制器是否正在 * @param key */ isLoading&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean /** * 获取单例控制器是否加载了 * @param key */ isLoaded&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean; /** * 获取单例控制器是否初始化了 * @param key */ isInited&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean; /** * 获取单例控制器是否显示 * @param key */ isShowed&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean; /** * 获取控制器类 * @param typeKey */ getCtrlClass&lt;keyType extends keyof CtrlKeyMapType&gt;(typeKey: keyType): CtrlClassType&lt;ICtrl&gt;;&#125; 这里有一些TypeScript的类型编程魔法。可以实现及其强大的类型提示。看不懂的可以先忽略，先来讲一下接口设计 在设计这个UI管理接口时，一直念着：职责是管理UI，提供接口调用UI，不做多余的事情。为什么？因为脑子里总有很多功能想要塞进去，但其实都只是我想要的不必要的功能 所以设计得很克制，资源处理接口外包出去了，因为职责是管理UI，提供接口调用UI 什么栈式UI管理啊，也没有做，因为并不是所有项目都需要，只是特殊需求。 所有项目都需要的是：管理UI，提供接口调用UI。 既然讲到管理UI，那游戏开发中都有哪些UI呢？ 如果按具体的讲，各有各的说法，什么Dialog啊，Tips啊，Window啊等等,说不完的! 我抽象一下，按照同时存在多少个UI实例来分：只有两种类型的UI 单例UI 比如：通用加载界面，养成界面，角色展示界面，战斗界面等等，同时有且仅有一个实例存在 多实例UI 比如：奖励获得tips，属性提升tips 那业务逻辑通过UI管理器 调用显示UI，就是想如果有就直接显示出来，没有就加载创建一个来显示 调用显示n个UI，就是想创建n个UI同时显示不同的内容 这个抽象逻辑是我能想到的所有游戏项目都通用的逻辑。 那UI管理的接口设计就应该是：提供调用单例UI和多实例UI的接口。仅此 大家估计都看到了很多特殊的类型声明，下面我简单的讲一下这些类型声明的作用 类型提示优化如果想要更加舒适的接口调用体验，那么就必须榨干typescript的类型系统提供的能力（ps:有为什么不用？）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//displayCtrl.IMgrisLoading&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean//实现UIimport &#123; BaseDpCtrl &#125; from \"./base-dp-ctrl\";declare global &#123; interface ITestCtrlKeyType &#123; OnUpdateDpc: \"OnUpdateDpc\", OnShowDpc: \"OnShowDpc\", OnInitDpc: \"OnInitDpc\" &#125; interface ITestCtrlShowDataMap &#123; OnShowDpc: number &#125; interface ITestCtrlInitDataMap &#123; OnInitDpc: number &#125; interface ITestCtrlUpdateDataMap &#123; OnUpdateDpc: number &#125;&#125;export class OnUpdateDpc extends BaseDpCtrl &#123; public static readonly typeKey: \"OnUpdateDpc\" = \"OnUpdateDpc\"; public updateData: number; constructor() &#123; super(); &#125; onUpdate(updateData: number) &#123; this.updateData = updateData; &#125;&#125;export class OnShowDpc extends BaseDpCtrl &#123; public static readonly typeKey: string = \"OnShowDpc\"; public showData: number; constructor() &#123; super(); &#125; onShow(config: displayCtrl.IShowConfig&lt;\"OnShowDpc\", ITestCtrlShowDataMap&gt;) &#123; this.showData = config.onShowData; super.onShow(config) &#125;&#125;export class OnInitDpc extends BaseDpCtrl &#123; public static readonly typeKey: \"OnInitDpc\" = \"OnInitDpc\"; public initData: number; constructor() &#123; super(); &#125; onInit(config: displayCtrl.IInitConfig&lt;\"OnInitDpc\", ITestCtrlInitDataMap&gt;) &#123; this.initData = config.onInitData; &#125;&#125;//实例化UI管理器const dpcMgr = new DpcMgr&lt;ITestCtrlKeyType,ITestCtrlInitDataMap,ITestCtrlShowDataMap,ITestCtrlUpdateDataMap&gt;();//注入类型ITestCtrlKeyType dpcMgr.init(&#123; loadRes: (config) =&gt; &#123; config.complete(); &#125; &#125;); dpcMgr.regist(OnUpdateDpc); dpcMgr.regist(OnInitDpc); dpcMgr.regist(OnShowDpc);//调用一个简单的dpcMgr.isLoading(\"\")//当双引号敲出，就会弹出类型提示选择:OnUpdateDpc，OnShowDpc，OnInitDpc//调用一个复杂的dpcMgr.showDpc(\"\")//当双引号敲出，就会弹出类型提示选择:OnUpdateDpc，OnShowDpc，OnInitDpc,//同时，需要传递onShowData时，也会有对应UIkey的onShowData类型提示dpcMgr.showDpc(\"OnShowDpc\",&#123;&#125;) 为什么要设计这样的类型提示？ 我想让UI逻辑实现者更加专注，只需要在顶部添加声明,业务逻辑调用就知道该传什么数据了。不用去翻找文件找接口 12345678910111213141516declare global &#123; interface ITestCtrlKeyType &#123; OnUpdateDpc: \"OnUpdateDpc\", OnShowDpc: \"OnShowDpc\", OnInitDpc: \"OnInitDpc\" &#125; interface ITestCtrlShowDataMap &#123; OnShowDpc: number &#125; interface ITestCtrlInitDataMap &#123; OnInitDpc: number &#125; interface ITestCtrlUpdateDataMap &#123; OnUpdateDpc: number &#125;&#125; 我想让UI调用者：业务逻辑，调用得更加舒服、无依赖、无import 关于typescript类型编程参考资料 编写TypeScript工具类型，你需要知道的知识 TypeScript 的工具类型 深入 TypeScript 的类型系统 TypeScript系列（三）从编程语言到Conditional Types 其他可能性虽然这篇文章讲的是UI管理框架 但其实我代码里和接口设计的方向并不限制只是UI管理，你可以用于管理各种抽象显示单位 UI只是其中一种，这个抽象显示单位可以是 一个小部件 主角 敌人 子弹 等等 它不只是UI框架，它是通用显示管理框架 总结关于UI框架的设计，提出UI业务实现中的两个本质的需求 高效、灵活且专注的UI逻辑实现 高效、灵活且高可扩展的UI管理 分析本质需求，提出更加细化的需求 根据需求设计和实现了一套跨引擎零依赖高效灵活高可扩展的UI框架。 适用于所有游戏引擎项目，可以根据自身需求任意扩展 并且通过研究typescript的类型编程，为接口调用提供了超级舒适的类型提示 具体的实现逻辑和CocosCreator2.4.2的demo，大家可以移步框架 GitHub仓库：EasyGameFrameworkOpen 希望大家可以给个star,谢谢~ 谢谢大家阅读我的文章~ 祝大家周末愉快~ 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 框架的诞生-二：定位 通用游戏UI框架的设计与实现 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 (欢迎前来讨论吹水) 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"},{"name":"分类2","slug":"框架设计/分类2","permalink":"http://yoursite.com/categories/框架设计/分类2/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/tags/框架设计/"}],"keywords":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"},{"name":"分类2","slug":"框架设计/分类2","permalink":"http://yoursite.com/categories/框架设计/分类2/"}]},{"title":"框架的诞生-二：定位","slug":"The-birth-of-the-framework-two-positioning","date":"2020-12-02T14:14:52.000Z","updated":"2021-04-18T09:27:04.583Z","comments":false,"path":"2020/12/02/The-birth-of-the-framework-two-positioning/","link":"","permalink":"http://yoursite.com/2020/12/02/The-birth-of-the-framework-two-positioning/","excerpt":"","text":"前几天发布了我的框架，EasyGameFramework ，也发了几篇文章来分享我的心得和想法。之后在跟一些小伙伴的交流中收获很多。初次写文章，有些地方可能没表达清楚，大家可能一些疑惑。所以想了一下，写了下这篇文章，主要讲一下关于这个框架的定位。 框架:源码传送门 什么是定位？ 定位是一个汉语词汇，读音dìng wèi，意思是指确定方位，确定或指出的地方，确定场所或界限（如通过勘察）给这个地产的界限定位。出自《韩非子·扬权》。 第一篇文章 : 框架的诞生-零：为什么写框架？中有讲到，框架是解决特定领域问题的。 所以在这里我想要讲的定位是，如何划定框架解决问题的领域，以及方向。 为什么要定位呢？这里不得不提Vue这个框架，以及其作者尤雨溪尤大。我相信有很多人都认识。CocosCreator的编辑器所用的前端框架就是vue+Eletron。 这里有一篇对尤雨溪大佬的采访文章:比较详细的采访 Vue 作者尤雨溪，这篇采访中尤雨溪谈到了对vue的定位 在所有框架中，我自己创造了一个概念叫渐进的框架。因为 Vue 的核心组成只是数据绑定和组件，和 React 差不多。它只是解决了一小部分很重要的痛点。与 React 相比，Vue 可能更简单易用，只知道一些 HTML，JavaScript 和 CSS 知识的人都可以很快入门 Vue。 在框架层面上，我是用一个非常精简和尽可能小的的内核来构建的。但是当构建更复杂的应用的时候，有很多其他的问题需要解决。比如说路由，或者说怎么处理跨组件通信，怎么样在大型应用程序中共享状态，这样的话我们就还需要更多的构建工具来模块化我们的代码库。 怎么样来组织样式和各种各样的静态资源？像 Ember 或 Angular 这些非常完整的框架，它们就想解决所有可能遇到的这些问题，并把这些功能全都集成到框架中。 这就叫有得必有失吧。对用户使用情况的假设越多，框架最终的灵活性就越低。或者像 React 这样把很多问题都留给社区。React 社区是非常非常活跃的，经常有很多牛 X 的想法跳出来，当然也有不少不完美的想法。Vue 就是比较折中，仍然保持一个很小的核心，只提供一些最重要的功能。但是我们还是在逐渐提供一些更多的独立解决方案，比如说路由，状态管理，构建工具链和 CLI。它们都是官方维护的，有很好的文档，设计的也非常好，可以各种搭配使用，但重点是不需要的时候就可以不用。我认为这可能是 Vue 作为一个框架最大的特色。 就在今年Vue3.0也发布了，它在这条道路上更加极致了。有兴趣的小伙伴可以了解一下，掘金上也有很多分析的文章。 我对此的理解:渐进的框架，提供一个非常精简，尽可能小的内核。来满足基本需求。然后逐渐提供一些官方维护的帮助构建复杂应用的独立解决方案，可以各种组合搭配使用，不需要时可以不用。同时也可以自己开发定制自己的库。 一个框架需要有自己的定位，要么精简无比，就像react一样，就做个渲染库。或者像Angular一样，大而全。亦或者像vue一样折中，渐进。 一开始，我在慢慢搭建自己的框架时，心潮澎湃，激情满满。想要有很多很多功能，也实现了很多功能模块。但是，有时候想用一部分功能时，不好拆分，用了之后同步和维护也会变得麻烦。(ps.当时用Laya3d在开发rpg挂机项目，框架已经具备大部分功能模块了，也想开源出来，但想了想只是芸芸众轮中一个大同小异的轮子，没啥好分享的，也不好维护。) 大而全的路子不适合我，因为时间精力没那么多，而且价值和意义不大。 所以我选择了渐进。 这一个转变，让我更多地关注手中的业务，关注多人协作，以及对需求、问题的思考。去学习不同框架的设计思路，以及了解它们如何去解决它们界定的领域的问题。 我将我认为最重要最核心的模块分离出来，进行研究，实践和迭代，尽量打磨到更好的状态。 虽然我选择的方向和Vue相似，但不能比的。 框架核心的定位 极致轻量级 这样它就可以轻易融入任意阶段的项目，比如你想要一个舒服的全局调用不同模块的接口的体验，那它的添加几乎无感，就130多行的源码，未压缩就10kb。 引擎无关性 不受限于任意引擎，只要是能用js/ts开发的程序，都可以用。如果你希望获得在不同项目中拥有一致的编码和模块管理体验的话。 可插拔可扩展的模块化机制 核心库提供的机制，可以让你可以创造多种方式去管理你的业务和基础模块，你可以在里面套pureMvc那套规范，也可以简单的横向扩展。使用面向接口编程，你可以动态地根据平台，环境，替换具体模块实现。 灵活可扩展的模块生命周期 模块生命周期可以方便管理模块之间的依赖，以及可以扩展自己业务环境所需的生命周期。 比如登陆，登陆之后，断线，重连，屏幕尺寸变化，进入后台，要做引导了…等等 论坛上有个小伙伴@zzzz.leung问到我 模块之间的依赖怎么处理呢？一个框架应该需要提供模块裁剪能力以减少代码包大小吧？因为迭代的功能越多，框架会越庞大复杂。 其实这个模块生命周期的用法在框架的诞生-一：我想要的框架就有说到，不知道是不是你想要的。 start, afterStart 这些生命周期 接口跟 cocos 和 Unity 的组件式接口很像。 主要是方便处理不同模块之间的依赖引用。比如：A 依赖了 B，但 B 还未初始化。 各自的初始化，都在 start 里处理，然后在 afterStart 里进行依赖调用。 可能对于不同的业务，这些生命周期可能不够用，可以根据具体业务进行扩展，满足自定义需求。 比如登录业务相关的： C 模块依赖 A 和 B 登录后的数据状态，那么增加两个接口 onLoginInit,onAfterLoginInit。 那么 A 和 B 实现 onLoginInit 接口进行登录初始化，C 在 onAfterLoginInit 接口进行依赖调用。 模块自动裁剪这种功能，太高级了。这个是在编译层做的处理，比如摇树Treeshake优化，将没有调用过的函数代码剪掉。 随着功能迭代开发，框架的确会越来越庞大，这个时候就需要开发者自己去整理了，这个可能任何框架都没办法帮你自动处理。有人可能说:人家CocosCreator可以啊。这个是官方提供的对引擎的模块进行剔除。你自己扩展一堆模块，可能需要你自己去决定剔除哪些了。同样，我所提供的模块，你可以按需使用。 可以参照这两张图▼ 我提供的一些模块有我个人从业务开发中实践然后沉淀比如显示管理模块display-ctrl，也有我基于兴趣写的，比如imgui编辑器开发库。 框架库构建工具的定位 用于导出多模块规范的typescript库 可以做nodejs工具开发，通用库开发，引擎扩展库开发、、、 其实这个平时的业务开发不推荐使用这个工具将模块，独立起来开发。只有当这个模块需要多项目内共用，开源分享，抽离沉淀时使用。因为会增加维护成本。平时开发怎么方便就怎么来。 EasyGameFramework仓库的定位开源和持续维护这个项目主要是开源和持续维护框架提供的一些重要的基础模块。 包括不仅限于 前端基础模块（显示，资源，消息状态，网络等） 引擎扩展模块 基础模块的引擎实现 抛砖引玉给大家提供一个开发框架的实践参考，也方便大家交流框架开发，业务开发等 也鼓励更多的人参与和交流，游戏开发路上不孤单。 H5游戏技术中台实践参考这个说的有点夸张，但意思是那个意思，就是沉淀技术进行多项目共享的实践 游戏引擎，属于游戏程序里的渲染层级，如果能将业务和渲染很好的分离，将业务和渲染扩展分别沉淀，不仅有益于提高现有项目的开发效率。而且将来如果做下一个项目，甚至切换引擎做项目，那么这个沉淀就可以让我节省很多时间，花更多的时间来专注业务和游戏性逻辑的研发，提高项目开发效率。 如果用了fairygui这种第三方UI解决方案，连UI资产也可跨项目跨引擎，那也可以节省很多时间。 当然也可以参照这个项目去打造公司的技术中台。 如果想做一个免费私有的npm源，可以借助coding免费打造私有的制品库。感兴趣的可以了解一下CODING 制品库 | 版本化的制品管理 这个项目是基于monorepo，主要是为了方便多模块项目开发和共享。 了解一下monorepo资料 白鹭的egret pro 就是使用了monorepo的方式进行开发。 【PPT】白鹭引擎首席架构师@王泽：框架开发中的基础设施搭建 ▼ 当然这个好不好用，看个人和团队。 我自己使用的感觉就是，多个独立模块同时开发，一个包写完代码，另一个包就可以像npm install 之后那样用，反馈非常快，非常舒服。 就是指令稍微有点复杂这个不太舒服，开发久了就习惯了 如果是分开仓库，本地开发还好，可以使用npm link，但如果多人协作，就麻烦了。 而且本地开发需要npm link 这个和install不太一样，就是和具体的使用环境不同。 谢谢大家阅读我的文章，希望大家能有所收获。 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 框架的诞生-二：定位 不只是 UI 管理:通用显示管理 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/tags/框架设计/"}],"keywords":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}]},{"title":"打破CocosCreator3d不能使用npm包的魔咒!!!","slug":"Break-the-spell-that-CocosCreator3d-cannot-use-NPM-packages","date":"2020-11-30T14:36:20.000Z","updated":"2020-11-30T16:00:29.540Z","comments":false,"path":"2020/11/30/Break-the-spell-that-CocosCreator3d-cannot-use-NPM-packages/","link":"","permalink":"http://yoursite.com/2020/11/30/Break-the-spell-that-CocosCreator3d-cannot-use-NPM-packages/","excerpt":"","text":"背景 我在开发EasyGameFramework这个框架的时候，目标之一是构建出来的模块包可以在CocosCreator3D上使用，使用体验和正常使用具有类型声明的Npm包一致。实在不行再用发布源码的方式。 在js生态中npm有很多很强大很有用的模块包 论坛上也有小伙伴对在CocosCreator3d上使用npm包有需求。 但CocosCreator3D的模块机制和CocosCreator不同，所以暂不支持直接使用npm包。 那怎么办呢？首先了解一下CocosCreator3d模块机制 CocosCreator3d模块机制这个时候就得祭出调试的杀手级工具:Chrome Devtools 调试运行CocosCreator3d空项目查看index.html CocosCreator3d中使用了system.js，并且在index.html注册了一个叫 code-quality:cr的模块 而且加载了一个.import-map.json的东西 搜索.import-map.json看看是什么 通过以上的调试我们大概知道，CocosCreator3d使用了一个叫systemjs的库，然后呢，用来注册一些模块。这个systemjs可能是关键的东西，得了解一下。 SystemJS的官方github:https://github.com/systemjs/systemjs 别人的使用:SystemJS使用记录 了解过后，我们能知道它就是一个模块加载器，以及它的注册方式 通过一个map注册一堆模块 通过register接口注册一个模块 但是怎么处理引用的呢？ 断点调试systemjs找到systemjs，搜索register 搜索importMap之类的关键词 通过以上调试验证了我们的猜想：SystemJs，用来注册和加载模块的，是一种模块规范，需要做特殊处理才能注册进去和使用。但我们需要来写一个简单的systemjs规范的模块来验证一下。 手写一个简单的SystemJs的模块 simple-sysjs.js 12345678910111213System.register('simple-sysjs', [], function (exports) &#123;'use strict'; return &#123; execute: function () &#123; var SimpleSysJs = exports('SimpleSysJs', /** @class */ (function () &#123; function SimpleSysJs() &#123; console.log(\"我是简单的systemjs模块\") &#125; return SimpleSysJs; &#125;())); &#125; &#125;;&#125;); 声明文件:simple-sysjs.d.ts 1234declare module 'simple-sysjs' &#123;export class SimpleSysJs &#123; &#125;&#125; 为了保证这个脚本优先于其他脚本加载，将simple-sysjs.js设置为插件 然后在编辑器新建脚本，写下 12import &#123; SimpleSysJs &#125; from \"simple-sysjs\"new SimpleSysJs() 运行后可以看到输出:我是简单的systemjs模块 这个很简单的，大家都可以新建一个空C3d项目尝试一下。 经过验证尝试，我们知道，只要将npm包转成systemjs规范的文件就可以被我们的代码引用，以及正常使用了。但手写太麻烦了，有什么简单的办法呢？ 如何快速地转换npm包为systemjs规范库使用egf-cli这个工具是我为EasyGameFramework打造的，目的是可以发布框架库为任意规范模块，给不同的引擎和项目使用。 有兴趣可以看看我之前写的文章 框架的诞生-一：我想要的框架 以及框架仓库:https://github.com/AILHC/EasyGameClientFramework.git 使用这个工具对npm包有一定的要求 符合commonjs规范 最好有类型声明文件 最好能是typescript开发的 我以xstate（一个高star的状态机库）为例子 c3d项目下安装 xstate ,npm i xstate 然后复制 EasyGameFrameOpen的package-template项目 修改包名为 1\"name\": \"@ailhc/xstate2c3d\", 修改构建命令为 1\"build:system\": \"egf build -f system:@ailhc/xstate2c3d\", 删除其他ts文件，留下index.ts 然后写一句: 1export * from \"xstate\" 最后执行 yarn run build:system 最后的最后，因为xstate里引用了node的变量，所以在构建出来的index.js要加一句 12345sendParent: sendParent,sendUpdate: sendUpdate,spawn: spawn &#125;);var process = &#123; env: &#123; NODE_ENV: \"production\" &#125; &#125; 复制lib和types到c3d项目，将index.js设置为插件 在任意脚本引用就可以 1234567891011121314151617181920212223import &#123; createMachine, interpret &#125; from \"@ailhc/xstate2c3d\"// Stateless machine definition// machine.transition(...) is a pure function used by the interpreter.const toggleMachine = createMachine(&#123; id: 'toggle', initial: 'inactive', states: &#123; inactive: &#123; on: &#123; TOGGLE: 'active' &#125; &#125;, active: &#123; on: &#123; TOGGLE: 'inactive' &#125; &#125; &#125;&#125;);// Machine instance with internal stateconst toggleService = interpret(toggleMachine) .onTransition((state) =&gt; console.log(state.value)) .start();// =&gt; 'inactive'toggleService.send('TOGGLE');// =&gt; 'active'toggleService.send('TOGGLE');// =&gt; 'inactive' xstate2c3d的工程已经更新到EasyGameFrameOpen：https://github.com/AILHC/EasyGameFrameworkOpen.git 其他方式 如果npm包有构建systemjs，直接使用 如果没有构建systemjs，看是否有typescript源码，copy源码，使用egf-cli构建一个systemjs规范的js 如果是全局变量的库，直接设置为插件就可以了。 CocosCreator3.0?它也许会支持npm包，但等待它的到来可能还有一段时间 而且研究一下CocosCreator3d的模块加载机制说不定，在遇到看不懂的问题时有所头绪呢。 谢谢大家阅读我的文章，希望大家能有所收获。 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 不只是 UI 管理:通用显示管理 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"EasyGameFramework使用","slug":"EasyGameFramework使用","permalink":"http://yoursite.com/categories/EasyGameFramework使用/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"CocosCreator3d","slug":"CocosCreator3d","permalink":"http://yoursite.com/tags/CocosCreator3d/"}],"keywords":[{"name":"EasyGameFramework使用","slug":"EasyGameFramework使用","permalink":"http://yoursite.com/categories/EasyGameFramework使用/"}]},{"title":"框架的诞生-一：我想要的框架","slug":"The-Birth-of-a-Framework-One-The-Framework-I-Want","date":"2020-11-29T09:23:49.000Z","updated":"2021-04-18T09:27:04.580Z","comments":true,"path":"2020/11/29/The-Birth-of-a-Framework-One-The-Framework-I-Want/","link":"","permalink":"http://yoursite.com/2020/11/29/The-Birth-of-a-Framework-One-The-Framework-I-Want/","excerpt":"","text":"目录[TOC] 我想要的框架是什么样的？ 上一篇文章: 《框架的诞生-零：为什么写框架？》里有讲 什么是框架。 框架是一个架子，在游戏程序中，抛开渲染层引擎框架，我们的指的框架就是支撑业务逻辑的架子，也是一个框框，规范和约束着开发人员。 每个框架都有着自己的边界，解决特定领域问题的。 那我们从去分析我遇到了什么问题，有什么需求，如何解决问题，如何实现需求。 无论是小项目还是大项目，或者是一个会不断扩张的项目，都希望能够项目代码结构清晰有条理，管理好不同模块。 框架:源码传送门 我尝试过的方式Manager of Managers很多框架都用这种方式（包括我之前写的框架） 这是刘钢老师的《Unity 项目架构设计与开发管理》中讲到的一种相对较好的方式 ▼ 优点是:类似于分级结构，各司其职；比如音频管理，场景管理，关卡管理等，每一个都是一个单例脚本，配合使用。结构相对清晰。可以复用 但我个人不太喜欢的点 调用不方便，调用链太长，费手指。比如 UIManager.getInstance().showUI 或者 UIMgr.ins.showUI 我想这样: m.uiMgr.showUI 少敲几个字母，也不想 import UIMgr 无生命周期统一管理，单例初始化和依赖不太可控。惰性初始化，等到调用 getInstance 才初始化。 控制台调试调用不方便，单例可能得单独绑定暴露到全局才能，每个模块都得这样做才行 直接依赖不可动态替换 有个模块我想在不同的平台切换成不同的实现，单例做不到。 大多耦合引擎来开发，只能在同引擎项目进行复用 模块字典挂载到全局变量 window这是我之前的框架使用的方式 就是将所有的模块初始化，然后注入一个模块字典 然后将字典挂载到全局的一个变量中。 1234567891011121314151617export class Main &#123; constructor()&#123; const moduleMap = &#123; &#125;; moduleMap[\"uiMgr\"] = new UIMgr(); moduleMap[\"netMgr\"] = new NetMgr(); window[\"aa\"] = moduleMap; &#125;&#125;class UIMgr &#123;&#125;class NetMgr &#123;&#125; 优点：调用方便 缺点: 有点危险，别人知道了可以在控制台调用进行调试。 这些方式在模块管理上都有问题，先不考虑如何方便调用，先实现个如何管理模块的核心机制。 一个具有生命周期的模块化机制pomelo 给我的灵感这个想法的灵感来自 pomelo 一个网易开发的基于 nodejs 的分布式服务器框架。 pomelo 支持可插拔的 component 扩展架构 用户只要实现 component 相关的接口： start, afterStart, stop, 就可以加载自定义的组件： 1app.load([name], comp, [opts]) start, afterStart 这些生命周期 接口跟 cocos 和 Unity 的组件式接口很像。主要是方便处理不同模块之间的依赖引用。比如：A 依赖了 B，但 B 还未初始化。 各自的初始化，都在 start 里处理，然后在 afterStart 里进行依赖调用。 可能对于不同的业务，这些生命周期可能不够用，可以根据具体业务进行扩展，满足自定义需求。 比如登录业务相关的： C 模块依赖 A 和 B 登录后的数据状态，那么增加两个接口 onLoginInit,onAfterLoginInit。 那么 A 和 B 实现 onLoginInit 接口进行登录初始化，C 在 onAfterLoginInit 接口进行依赖调用。 怎么实现我想要的框架？模块生命周期图 ▼ 接口设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778declare global &#123; namespace egf &#123; interface IModule &#123; /**模块名 */ key?: string /** * 当初始化时 */ onInit?(app: IApp): void; /** * 所有模块初始化完成时 */ onAfterInit?(app: IApp): void; /** * 模块停止时 */ onStop?(): void; &#125; type BootEndCallback = (isSuccess: boolean) =&gt; void; /** * 引导程序 */ interface IBootLoader &#123; /** * 引导 * @param app */ onBoot(app: IApp, bootEnd: BootEndCallback): void; &#125; /** * 主程序 */ interface IApp&lt;ModuleMap = any&gt; &#123; /** * 程序状态 * 0 未启动 1 引导中, 2 初始化, 3 运行中 */ state: number; /** * 模块字典 */ moduleMap: ModuleMap; /** * 引导 * @param bootLoaders */ bootstrap(bootLoaders: egf.IBootLoader[]): Promise&lt;boolean&gt;; /** * 初始化 */ init(): void; /** * 加载模块 * @param module */ loadModule(module: IModule | any, key?: keyof ModuleMap): void; /** * 停止 */ stop(): void; /** * 获取模块实例 * @param moduleKey */ getModule&lt;T extends IModule = any&gt;(moduleKey: keyof ModuleMap): T; /** * 判断有没有这个模块 * @param moduleKey */ hasModule(moduleKey: keyof ModuleMap): boolean; &#125; &#125;&#125;// eslint-disable-next-line @typescript-eslint/semiexport &#123; &#125; Bootloader: CatLib 给我的灵感这里有一个 bootloader 的东西我没有讲到，它的灵感来自 CatLib，一个我觉得很棒的 Unity 框架。 这个机制是什么呢？以开发测试环境和生产环境举例。 有一个 debugBootLoader，这个引导程序处理一些测试用的模块加载和初始化，杂七杂八的。 当你发布生产环境时，可以通过 debug 变量屏蔽加载这个引导程序，也可以通过编译工具剔除这段代码。 具体实现可以看：https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/packages/core#readme 怎么使用?具体使用请看 demo 工程 cocoscreator2.x 的 demo https://github.com/AILHC/egf-ccc-empty cocoscreator3d 的 demo https://github.com/AILHC/egf-ccc3d-empty 如何接入项目▼ 1234567891011121314151617181920212223242526272829303132//FrameworkLoader.tsimport &#123; HelloWorld &#125; from \"../HelloWorld\";export class FrameworkLoader implements egf.IBootLoader &#123; onBoot(app: egf.IApp, bootEnd: egf.BootEndCallback): void &#123; const helloWorld = new HelloWorld(); app.loadModule(helloWorld); bootEnd(true); &#125;&#125;//AppMain.tsimport &#123; App &#125; from \"@ailhc/egf-core\"import &#123; FrameworkLoader &#125; from \"./boot-loaders/FrameworkLoader\";import &#123; setModuleMap, m &#125; from \"./ModuleMap\";/** * 这是一种启动和初始化框架的方式，在cocos加载脚本时启动 * 不依赖场景加载和节点组件挂载 */export class AppMain &#123; public static app: App&lt;IModuleMap&gt;; public static initFramework() &#123; const app = new App&lt;IModuleMap&gt;(); AppMain.app = app; app.bootstrap([new FrameworkLoader()]); setModuleMap(app.moduleMap); app.init(); window[\"m\"] = m;//挂在到全局，方便控制台调试，生产环境可以屏蔽=&gt;安全 m.helloWorld.say(); &#125;&#125;AppMain.initFramework(); 接入项目很简单，new 一下，bootstrap，init 就可以了~ 注入模块也很简单 12345678//在UIMgr.ts开头增加个声明declare global &#123; interface IModuleMap &#123; uiMgr:UIMgr &#125;&#125;//在初始化地方，注入实例app.loadModule(UIMgr.getInstance(),\"uiMgr\"); 注入的模块是什么类型的，不限制，你可以将业务模块 比如 HeroModule 注入进去，那么业务模块之间就可以直接调用了。也不用担心 typescript 的循环引用了。 举个栗子（随便的）: 12345// BattleModule.tsm.hero.showHero(1);//HeroModule.tsm.battle.startTestBattle(1); 就像服务端的 rpc 调用一样。 12app.rpc.chat.chatRemote.kick(session, uid, player, function(data)&#123;&#125;); 至于怎么使得接口调用更方便，这个看个人的喜好，我呢，用了一点点魔法，让自己用着舒服又有点安全感。具体实现细节请看 demo 我想在 CocosCreator 和 C3d 中使用由于我的工作中是用 Laya 的，项目也用了这个框架。但我私底下都是玩 CocosCreator 和 CocosCreator3d 的(为什么啊？你懂得 😉😉) 我不想在项目之间将源码拷贝来拷贝去，迭代更新同步麻烦。 如果能像 npm 包一样 安装就好了。而且核心模块是一个模块，其他模块也是一个模块。 于是我开发了一个模块编译发布的工具，开发之前以为很简单，实际上，踩坑了好久 😂。 这个模块编译发布工具有什么功能？ 编译模块成 iife、commonjs、systemjs 格式的 js 文件 自动生成单个.d.ts 声明文件 这个 systemjs 格式的 js 文件可以让不支持 npm 包的 CocosCreator3d 可以像使用 npm 包一样使用。即使到时 Cocos3.0 支持 npm 了，使用方式也一模一样。使用 C3d1.2.0 发布 web，微信小游戏，验证运行没有问题。 123456789101112131415161718192021222324252627282930313233import &#123; App &#125; from '@ailhc/egf-core';//像引用npm包一样引用import &#123; _decorator, Component, Node &#125; from 'cc';import &#123; m, setModuleMap &#125; from './ModuleMap';import &#123; FrameworkLoader &#125; from './boot-loaders/FrameworkLoader';const &#123; ccclass, property &#125; = _decorator;@ccclass('AppMainComp')export class AppMainComp extends Component &#123; /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; onLoad() &#123; this._initFramework(); &#125; private _initFramework() &#123; const app = new App&lt;IModuleMap&gt;(); // new TestImport(); app.bootstrap([new FrameworkLoader()]); // app.bootstrap([new FrameworkLoader2()]); setModuleMap(app.moduleMap); app.init(); window[\"m\"] = m;//挂在到全局，方便控制台调试，生产环境可以屏蔽=&gt;安全 m.helloWorld.say(); &#125; start() &#123; &#125; // update (dt) &#123;&#125;&#125; 如何开发一个模块 克隆项目 git clone https://github.com/AILHC/EasyGameFrameworkOpen.git 复制 packages/package-template 项目，改文件夹名，改 package.json 里的项目名等信息 npm install 初始化项目 然后用 typescript 进行开发，使用 index.ts 文件将所有代码 export（可以使用 export-typescript 插件自动化，插件版本必须是 0.0.5 之前的） 使用 egf build 进行编译发布 总结一下框架有什么特性 轻量级模块化机制 模块生命周期 让模块的初始化有序，依赖可控 可面向接口编程 方便具体实现细节可替换，模块可动态替换 友好的类型声明 点一下就有类型提示，传字符串获取模块也有类型提示，很香的。 基于 TypeScript 与引擎无关 每个模块库都是一个 npm 包 模块库可以导出多种 js 格式，让 laya，ccc，c3d 使用，甚至给 Unity、Unreal 用(xLua 作者的 Puerts 了解一下？) 这个框架可以做什么？特性 基于轻量级无依赖的模块机制，可以为不同项目量身定制框架，可大可小。也可以根据项目的不同阶段进行渐进式扩展。还可以在项目的不同阶段轻易地接入 面向接口编程的模块，底层组件可以无感知替换 基于模块开发工具，我们可以开发和发布一个单独的对核心零依赖的模块，给不同的项目使用。 方便别的项目引用 方便开源 方便做单元测试 基于模块化机制和配套开发工具，大家可以为公司或者个人建立自己的模块库，在不同项目按需复用。 架构设想 ▼ 谢谢大家阅读我的文章，希望大家能有所收获。 谢谢大家阅读我的文章，希望大家能有所收获。 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 框架的诞生-二：定位 不只是 UI 管理:通用显示管理 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/tags/框架设计/"}],"keywords":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}]},{"title":"框架的诞生-零：为什么写框架？","slug":"The-Birth-of-Frames-Zero：Why-write-framework","date":"2020-11-17T07:53:39.000Z","updated":"2021-04-18T09:27:04.577Z","comments":false,"path":"2020/11/17/The-Birth-of-Frames-Zero：Why-write-framework/","link":"","permalink":"http://yoursite.com/2020/11/17/The-Birth-of-Frames-Zero：Why-write-framework/","excerpt":"","text":"目录[TOC] 题外话大家好，很高兴，能写这篇文章分享给你们看，也很感谢你们能看我的文章。如果能和你们交流最好了。做游戏开发3、4年了，我用过这些，Unity，Cocos2dx，CocosCreator，LayaAir，Egret。 用得最久的是LayaAir，因为工作需要嘛。 但最喜欢的还是CocosCreator，因为社区的小伙伴、引擎组的人都很好很可爱，他们分享的东西都让我受益匪浅。 谢谢~ 第一次写文章，如有不当之处请多多见谅。 框架:源码传送门 什么是框架？我想有的人心里有答案，有的人也有疑问。 这里我提供别人对框架的见解链接: 某乎文章:什么是框架？为什么要使用框架？我告诉你理由哦！ 123框架的英文为Framework意思是框架、机制、准则。最早是源于建筑行业，是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。 @金戈的回答: 什么是框架？ 123框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。IT语境中的框架，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构。在此结构上可以根据具体问题扩展、安插更多的组成部分，从而更迅速和方便地构建完整的解决问题的方案。 我的个人见解：▼ 我们的游戏程序都是基于某个平台的，以及可能会使用现成的渲染框架，来实现我们游戏的玩法和业务。同时针对开发和生产环境部署，我们需要一些工具协助。 框架在渲染框架层和业务层之间，封装部分通用能力供业务层使用。起到支撑业务开发的作用。 我的层级图的灵感来自 @白玉无冰 大佬拍的panda大大讲的一页一个PPT:CocosCreator跨平台的引擎架构。▼ 对于游戏客户端框架来说 框架具有一定的约束性，指的是，我们需要在一定范围内按照框架作者的设计和规范去使用和扩展。 比如： 在CocosCreator框架中。 如果要加载一个资源，那就需要调用cc.assetManager.loadxxx 或者cc.loader.loadxxx，传规定的参数，传错了就可能出问题。 如果需要加载自定义的资源就需要安装assetManager的规范去扩展。具体可参考CocosCreator的文档，不按规范扩展就可能出问题。 框架有部分已经实现的功能，可以直接使用或者稍微扩展就可以用来实现业务逻辑。 大部分游戏客户端框架都包含很多功能模块，甚至不是我们项目需要的。 比如： 框架中包含UI管理框架，事件通讯框架，网络模块，等等。 我们可能只需要事件通讯模块或者UI管理模块，只能手动去剔除不需要的。 框架所能解决的问题有限，有边界。 比如： 有的框架只是一个UI管理框架只解决了复杂UI管理的问题 框架可能跟底层强相关。 比如：一个基于CocosCreator的UI管理模块，里面耦合了CocosCreator的加载，prefab文件，resource文件夹的规范等，可能也耦合了cc.Node的使用等等。 框架解决什么问题？大家对框架的第一印象可能是 我学不动了 提高开发效率，快！！！ 我个人觉得好坏还得看框架和看个人 好的框架可以统一多个开发人员的编程风格，方便多人协作 好的框架可以让开发人员减少维护程序架构心智负担，减少纠结。 最重要的是可以大大的提高开发效率，大部分时间专心写业务就可以了。 为什么写框架？为了造一个更好更适合的轮子有现成的框架为什么不拿来直接用，干嘛自己造轮子浪费时间？ 现成的框架没法满足需求，有无法解决的问题。 现成的框架和自己的思想不符。 为了学习和实践写框架可以督促我去学习其他框架是如何设计的，为什么这样设计，能解决什么问题，为什么能解决这些问题。 然后反过来去思考我工作和开发中遇到的问题，我学着去分析，去尝试找解决方案，以及思考如果我写框架怎么解决这些问题。怎么去设计。 写出来的框架很挫怎么办？怕个毛线，继续学习，继续思考，然后解决问题，大不了推翻重写。 写出来的框架不能用在公司的项目中去实践怎么办？这个想法有点危险，哈哈哈，可以自己写项目来验证。不过还有另外一种解决方案。下一篇会讲。 写框架是一场历练，督促着我去学习和沉淀所学，打磨我的知识体系，让它更加完善。 总结 什么是框架？是游戏程序的一部分，是支撑游戏业务逻辑的架子，但也是具有一定约束的框框。 框架解决什么问题？ 可以统一多开发人员的风格（框架的风格） 可以让开发人员减少维护程序架构的心智负担，减少纠结（按照框架的思想来就行） 可以大大提高开发效率，大部分时间专心写业务逻辑就可以了 为什么写框架？ 去学习其他框架怎么设计，怎么解决它们面对的问题。 解决自己工作和开发中遇到的问题 积累和沉淀自己的知识 一些游戏客户端框架参考 CatLib 一个Unity的渐进式框架(ps：我的框架灵感之一) U3d网络游戏架构设计 一个大佬的GitChat专栏，需要订阅 腾讯学院的手游核心技术实战 这是腾讯学院的一个贪吃蛇大作战的一个游戏开发课程，讲到了如何设计和实现基于Unity的游戏框架 GameFramework 基于Unity的一个完善的框架 QFramework 基于Unity的一个完善且扩展性非常强的框架，而且作者有很多关于框架设计的理念，非常棒 UNITE －Unity项目架构设计与开发管理 文章：Unity项目架构设计与开发管理 【ituuz分享-框架】lightMVC:轻量级游戏开发框架(for cocos creator) GameplayFrameWork for CococsCreator 其他的还有很多，论坛搜 “框架”即可 心里话我想和优秀的小伙伴一起开发好玩的游戏 我希望能通过我做的游戏，我的能力获得用于生活和学习的报酬。 我也希望 有人能从我的游戏中获得快乐，或者有所收获 也希望 有人能因我的分享而有所收获 然后我能说一句 谢谢你玩我的游戏 谢谢你信任我 谢谢你用我的框架 谢谢大家阅读我的文章，希望大家能有所收获。 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 框架的诞生-二：定位 不只是 UI 管理:通用显示管理 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/tags/框架设计/"}],"keywords":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}]},{"title":"命令行使用记录","slug":"about-terminal-and-shell","date":"2020-03-08T07:02:40.000Z","updated":"2020-10-17T06:49:00.935Z","comments":false,"path":"2020/03/08/about-terminal-and-shell/","link":"","permalink":"http://yoursite.com/2020/03/08/about-terminal-and-shell/","excerpt":"","text":"在Mac上配置命令行工具使用 iTerm2 + zsh 参考资料 关于homebrew的安装 Mac下终端工具iTerm2安装在windows配置命令行工具使用 使用Cmder 参考资料 Windows终端利器Cmder","categories":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"}],"tags":[{"name":"terminal","slug":"terminal","permalink":"http://yoursite.com/tags/terminal/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}],"keywords":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"}]},{"title":"写作输出记录","slug":"how-to-wrrite-blog","date":"2020-02-28T01:52:16.000Z","updated":"2020-10-17T06:49:00.938Z","comments":true,"path":"2020/02/28/how-to-wrrite-blog/","link":"","permalink":"http://yoursite.com/2020/02/28/how-to-wrrite-blog/","excerpt":"","text":"写作输出记录个人博客 搭建参考 hexo史上最全搭建教程 hexo 官网文档 使用hexo+github搭建免费个人博客详细教程 使用Markdown写作 有道云笔记可以写Markdown笔记，然后copy到hexo个人博客仓库 也可以使用vscode直接写markdown markdown使用参考: 为什么要学Markdown？有什么用？ 各个平台 自媒体平台,参考：自媒体有哪些平台？ 博客平台 CSDN 简书 博客园 个人公众号 如何将markdown笔记发布到各个平台 使用Md2All转富文本 :Md2All 直接复制markdown笔记","categories":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"}],"tags":[{"name":"写作","slug":"写作","permalink":"http://yoursite.com/tags/写作/"},{"name":"输出","slug":"输出","permalink":"http://yoursite.com/tags/输出/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}],"keywords":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"}]},{"title":"Git使用记录","slug":"git-use-record","date":"2020-02-27T13:04:35.000Z","updated":"2020-10-17T06:49:00.937Z","comments":true,"path":"2020/02/27/git-use-record/","link":"","permalink":"http://yoursite.com/2020/02/27/git-use-record/","excerpt":"","text":"Git 使用记录Git学习资源Git问题记录SSHKey 怎么生成？ 123ssh-keygen -t rsa -C &quot;youremail&quot;默认会生成 名字 id_rsa 的sshkey 可以自己自定义,但再使用时可能会有问题 关于错误:ssh: Could not resolve hostname github.com: Name or service not known.fatal: Could not read from remote repository.参考解决方案: 在Github中使用 1234Settings-&gt;SSHKey -&gt; NewSSHKey将 id_rsa.pub(公钥) 文件的内容复制进去然后在git bash 执行:ssh -T git@github.com “执行:ssh -T git@github.com“ 出现Permission denied (publickey)参考解决方案 如果在创建sshkey时使用自定义文件名, 执行 ssh-add ~/.ssh/&lt;自定义sshkey名&gt; 可能会出现：Could not open a connection to your authentication agent 参考解决方案 文件名大小问题 缘由：原来的文件名是小写的文件，复制了大写的文件名文件，显示覆盖，但覆盖后，文件名还是小写的 解决方案： 参考：git 大小写问题 踩坑笔记 在项目目录下执行命令： 123touch .gitconfiggit config core.ignorecase falsegit config --global core.ignorecase false Git二进制文件管理以及如何git瘦身缘由在游戏开发过程中，会使用用到很多二进制类资源，比如 图片，配置压缩文件，3d资产文件等，由于git的工作原理，不断的commit会不断的累加。整个仓库会变得非常庞大。 二进制文件管理 参考资料a. Git 管理实战（五）：二进制大文件的版本控制b. Git LFS的使用c. 百度 git lfsgit 瘦身实践 参考资料a. Git清理删除历史提交文件https://www.jianshu.com/p/7ace3767986ab. 使用BFG移除git库中的大文件或污点提交c. 使用BFG清除git仓库中的隐私文件或大文件d. 为Git仓库瘦身e. git rebase有哪些用法？ 这个可以对项目进行瘦身 可以使用 gitlfs 来迁移仓库的管理方式而瘦身。但是这个会相对麻烦，需要远程仓库也支持。如果是使用gitee或者github等免费远程仓库则需要付费 将二进制或者所有资源文件使用svn进行管理a. 先备份资源文件b. 忽略管理对应资源文件c. 删除资源文件的版本记录d. 同步操作到远程仓库 定期对资源文件的版本记录进行清理","categories":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"},{"name":"资料收集","slug":"经验之谈/资料收集","permalink":"http://yoursite.com/categories/经验之谈/资料收集/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}],"keywords":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"},{"name":"资料收集","slug":"经验之谈/资料收集","permalink":"http://yoursite.com/categories/经验之谈/资料收集/"}]}]}