{"meta":{"title":"晴","subtitle":"游戏,写代码,做个好游戏~","description":"分享个人游戏编程的心得~","author":"Tide Li","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-01-20T13:29:32.000Z","updated":"2020-10-17T06:49:00.943Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-20T13:28:56.000Z","updated":"2020-10-17T06:49:00.944Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-20T13:24:44.000Z","updated":"2020-10-17T06:49:00.946Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-17T06:49:00.944Z","updated":"2020-10-17T06:49:00.944Z","comments":true,"path":"categories/关于作者/index.html","permalink":"http://yoursite.com/categories/关于作者/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-17T06:49:00.945Z","updated":"2020-10-17T06:49:00.945Z","comments":true,"path":"categories/想法流水/index.html","permalink":"http://yoursite.com/categories/想法流水/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-17T06:49:00.945Z","updated":"2020-10-17T06:49:00.945Z","comments":true,"path":"categories/经验之谈/index.html","permalink":"http://yoursite.com/categories/经验之谈/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-17T06:49:00.945Z","updated":"2020-10-17T06:49:00.945Z","comments":true,"path":"categories/资料收集/index.html","permalink":"http://yoursite.com/categories/资料收集/index.html","excerpt":"","text":""}],"posts":[{"title":"基于TypeScript的通用游戏UI框架的使用","slug":"基于TypeScript的通用游戏UI框架的使用","date":"2020-12-24T16:56:34.000Z","updated":"2020-12-24T16:56:34.076Z","comments":false,"path":"2020/12/25/基于TypeScript的通用游戏UI框架的使用/","link":"","permalink":"http://yoursite.com/2020/12/25/基于TypeScript的通用游戏UI框架的使用/","excerpt":"","text":"","categories":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"http://yoursite.com/tags/标签1/"},{"name":"标签2","slug":"标签2","permalink":"http://yoursite.com/tags/标签2/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"http://yoursite.com/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"http://yoursite.com/categories/分类1/分类2/"}]},{"title":"解决CocosCreator2.4.x的ABundle不能使用npm包的问题","slug":"解决CocosCreator2-4-x的ABundle不能使用npm包的问题","date":"2020-12-24T15:34:39.000Z","updated":"2020-12-24T15:36:35.488Z","comments":false,"path":"2020/12/24/解决CocosCreator2-4-x的ABundle不能使用npm包的问题/","link":"","permalink":"http://yoursite.com/2020/12/24/解决CocosCreator2-4-x的ABundle不能使用npm包的问题/","excerpt":"","text":"前言今天逛论坛时，我看论坛上有个小伙伴问cocoscreator能不能用npm包？ 帖子:cocos creator 工程里面能装npm包吗？ 我在想怎么可能不支持呢? 于是点击去看到了大佬的回答，也仔细看了大佬写的了一篇AssetBundle的讲解文章 Creator | Asset Bundle 全解析 这里说npm包都打进了main这个bundle了，分包里没法引用 这句话让我不禁想了一下，EasyGameFramework的所有库都是以npm包的方式安装使用的。 如果不能在分包引用，那不就很烦？ 我用egf-ccc-full的项目做了一个测试，发现预览可以，构建出来真的不行，加载bundle就直接报错了。 后来我尝试挂载到全局，可以正常运行，但编码体验下降一百倍，过程繁琐。 我忍不了了 之前就发现一个跟npm包相关的问题：不支持引用项目文件夹外的npm包，编辑器编辑和构建会报错（但预览不会）那个问题我已经解决了:CocosCreator2.4.2/2.4.3无法编译引用了项目文件夹外部的npm模块 所以我觉得这两个问题应该是差不多的。 今天我就让ABundle支持引用npm包！！！ @一下引擎组 问题重要吗?我觉得很重要! 虽然说可以将npm包的东西挂载到全局，然后在分包里的脚本，去全局取用。 但这样不安全。控制台也可以访问到了。 而且最重要的是，很别扭，你知道吧？这编码体验很不爽了。 EasyGameFramework的出发点就是要让编码更加Easy，更加爽。 所以今天我就让ABundle支持引用npm包！！！今天我就让ABundle支持引用npm包！！！让EasyGameFramework无缝支持分包使用 复现问题flag已经立了，说明我已经解决了。哈哈哈哈哈哈~ 它不可能倒下的~ 我们先把问题复现出来，看看是怎么回事。 只有构建之后才能看出问题，所以先构建一波，这里我使用egf-ccc-full来测试。 https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/examples/egf-ccc-full 大家可以克隆下来看看 我简单讲一下我的测试逻辑 加载abtest这个包：test/display-ctrl/abtest，然后将这个包里的ABTestModule注入模块管理器 通过abtest模块的逻辑，显示abtest里的界面 ABTestModule注入全局 ABTestView继承@ailhc/dpctrl-ccc包的NodeCtrl运行构建后的看看报错找不到模块，这个报错的模块名有点奇怪啊，不是我的包名@ailhc/dpctrl-ccc,被切了万能的断点调试 我们会发现，在分包的index.js找不到，只有两个包内的脚本模块对象 下一步。 然后它把包名切割了！！！！就这样就切割了？？？！！！为什么？ 给不懂的科普一下npm包名 · npm包名是没有./或者../的，大多是只有一个名字 比如xstate · 有一些特殊的包名比如:@babel/core，比如@ailhc/egf-core 继续跟踪，它进了一个require函数，然后跳转过去，发现这个index.js是main bundle里的通过切割后的名字dpctrl-ccc到main包里也没找到其实main包里应该是有这个包的，只是key不对。我通过调试main index.js中对@ailhc/dpctrl-ccc的引用其实是可以找到的，只是它的key 转化为4 调试总结通过这系列调试，我们可以知道 主包main里的index.js有npm包模块，也可以引用 分包里的index.js如果引用了包外的脚本模块，则会向上main包查找，查不到就报错 而这个分包向主包查找模块的逻辑里，没考虑到npm包名的情况 主包和分包里的index.js的开头那部分都很像，像是模板 总结完之后，我们就去根据我们调试的成果去尝试解决问题 如何来解决这个问题呢？首先得找到模板index.js开头通过进入编辑器目录，搜索文本__require找到了CocosDashboard\\resources.editors\\Creator\\2.4.2\\resources\\static_prelude.js12345678910111213141516171819202122232425262728(function e(t, n, r) &#123; function s(o, u) &#123; if (!n[o]) &#123; if (!t[o]) &#123; var b = o.split('/'); b = b[b.length - 1]; if (!t[b]) &#123; var a = \"function\" == typeof __require &amp;&amp; __require; if (!u &amp;&amp; a) return a(b, !0); if (i) return i(b, !0); throw new Error(\"Cannot find module '\" + o + \"'\"); &#125; o = b; &#125; var f = n[o] = &#123; exports: &#123;&#125; &#125;; t[o][0].call(f.exports, function (e) &#123; var n = t[o][1][e]; return s(n || e); &#125;, f, f.exports, e, t, n, r); &#125; return n[o].exports; &#125; var i = \"function\" == typeof __require &amp;&amp; __require; for (var o = 0; o &lt; r.length; o++) s(r[o]); return s;&#125;) 很像啊哈 简直就是🙄 然后我简单的加了一句log，发现重新构建之后输出出来了，说明改这个有效 然后呢，解决那个切掉我npm包名的逻辑先判断路径是什么类型的，再决定切不切 12345678var b = o;if (o.includes(\"./\")) &#123;//内部代码b = o.split(\"/\");b = b[b.length - 1];&#125; else &#123; //npm包代码&#125; 最后呢，因为主包中，npm包包名和模块对象的对应关系被转换了所以呢 我们在第一次引用的时候，判断是不是npm包，如果是，就以包名为key，记录一下，下次好用包名查找 123456789101112131415161718192021222324252627282930313233343536373839(function e(t, n, r) &#123; function s(o, u, npmPkgName) &#123; if (!n[o]) &#123; if (!t[o]) &#123; var b = o; if (o.includes(\"./\")) &#123; //内部代码 b = o.split(\"/\"); b = b[b.length - 1]; &#125; else &#123; //npm包代码 &#125; if (!t[b]) &#123; var a = \"function\" == typeof __require &amp;&amp; __require; if (!u &amp;&amp; a) return a(b, !0); if (i) return i(b, !0); throw new Error(\"Cannot find module '\" + o + \"'\"); &#125; o = b; &#125; var f = n[o] = &#123; exports: &#123;&#125; &#125;; t[o][0].call(f.exports, function (e) &#123; var n = t[o][1][e]; //判断是不是npm包，是就传包名 return s(n || e, undefined, !e.includes(\"./\") ? e : undefined); &#125;, f, f.exports, e, t, n, r); &#125; //判断是不是npm包，是就用包名作为key存一下模块引用 if (npmPkgName &amp;&amp; n[o] &amp;&amp; !n[npmPkgName]) &#123; n[npmPkgName] = n[o]; &#125; return n[o].exports; &#125; var i = \"function\" == typeof __require &amp;&amp; __require; for (var o = 0; o &lt; r.length; o++) s(r[o]); return s;&#125;) 重新构建，运行，没有报错~搞定散花~ 重要提示虽然说搞定了，但它还是有局限性的 比如，你主包没有引用过npm包，那么你分包也引用不了 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/categories/CocosCreator/"},{"name":"EasyGameFramework使用","slug":"CocosCreator/EasyGameFramework使用","permalink":"http://yoursite.com/categories/CocosCreator/EasyGameFramework使用/"}],"tags":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}],"keywords":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/categories/CocosCreator/"},{"name":"EasyGameFramework使用","slug":"CocosCreator/EasyGameFramework使用","permalink":"http://yoursite.com/categories/CocosCreator/EasyGameFramework使用/"}]},{"title":"通用游戏UI框架的设计与实现","slug":"Design-and-implementation-of-a-general-game-display-management-framework","date":"2020-12-19T14:06:23.000Z","updated":"2020-12-20T04:44:12.403Z","comments":true,"path":"2020/12/19/Design-and-implementation-of-a-general-game-display-management-framework/","link":"","permalink":"http://yoursite.com/2020/12/19/Design-and-implementation-of-a-general-game-display-management-framework/","excerpt":"","text":"@TOC 前言这个月月初，我发了几篇文章分享了我写框架的心路历程和一些自己的想法。感兴趣的可以通过文末链接回顾。 同时我发布了我的第一个开源渐进式H5游戏开发框架: EasyGameFrameworkOpen 提供强大轻量级的核心库:模块管理库 @ailhc/egf-core。可以无缝接入任意引擎游戏项目 以及提供一个基于rollup的typescript库构建工具: @ailhc/egf-cli，可以构建出适合任意引擎项目的js库和单一.d.ts声明文件 类似cocos.d.ts声明文件。 在之前的文章中，我也预告了，还有后续的分享。后续的分享也是关于框架其他库的设计与实现的。 虽然文章还没出，但一直在更新。 大家可以关注框架的github仓库，如果可以，给个star哦。 为什么鸽了这么久才更新呢？本来预期是上个星期更新的。 但是涅~(￣▽￣)~* 首先工作比较忙，家里又有事情需要处理 同时，接下来要讲的这个方面我觉得比较难，我想要讲清楚讲明白(原谅我稚嫩的笔触) 我想添加尽可能多的单元测试和demo例子(毕竟要往更加规范的工程化靠拢) 鸽子🕊 : 别哔哔，鸽了就是鸽了，赶紧进入正题~ 我: 好嘞~ 背景做游戏，绝大部分，UI交互界面是必不可少的。 当项目的UI界面多起来的时候，而且策划们的需求千奇百怪，迭代频繁的时候，就会让我们非常头疼。 接下来我将以我稚嫩的笔触分享我是如何分析和解决这个头疼问题的。 这个议题偏向主观和开放，每个人都有自己的业务开发经历和想法，而我就在此抛砖引玉，献丑了。 如有不足，请各位多多指教🙏( •̀ ω •́ )✧ 本质需求我们来看两种情景 策划提了一个需求:一个有五彩斑斓的黑背景的文本提示界面B-&gt;程序员去实现界面B的逻辑 点击A按钮-&gt;显示B界面 这两个情景就是我们开发中最最最常见，最最最本质的两个需求： 实现UI界面逻辑 调用界面 那么我们头疼也就是这两个需求的实现，我分别讲一下 UI逻辑的实现UI逻辑的实现是各种各样，需求也是千奇百怪。 而且这个实现可能不是一步就位的，可能还需要迭代，重做等。 那么在这种情况下，我作为UI逻辑的开发者，我希望 不用关注别的业务逻辑在什么地方怎么调用我，只需要通过告诉外界如何调用我 拥有足够高的自由度 我不一定要加载prefab，我希望可以加载一个图片来动态new一个node来添加组件显示 也不一定要实例化prefab，作为显示节点，我希望可以通过绘图api自己画界面显示 我不一定要用cocoscreator的显示渲染，我希望可以通过写html显示，可以接fgui显示，可以调用安卓和ios的原生界面显示 我不一定使用通用的加载释放逻辑，我希望可以自定义加载和资源释放逻辑 可以自己控制节点添加到那个父节点。 可以依赖多个不同类型的资源，动态生成 在不改变函数接口的情况下，拥有足够高的扩展性 这样高可扩展，高自由度，对外界透明可以让开发者更加专注高效地实现和迭代UI逻辑。 不用因为别人调用不规范导致出bug而头疼 不用因为束手束脚而头疼 不用为想扩展又不想改接口而头疼 UI的调用我们在项目开发中可能会有各种UI调用的需求： UI调用最复杂也是最常用的是显示调用，比如 显示A界面 显示B界面并按照B界面的显示数据接口传递数据给B界面，B按照传递的数据渲染，甚至传递各种回调 显示C界面，想C显示接口调用后回调显示完成回调，即想在界面显示完成后执行逻辑 其他常用的是 更新 隐藏 销毁 还有一些特殊的比如：预加载指定界面（不显示），获取指定界面依赖的资源（用于批量加载多个界面依赖的资源） 除了对功能的需求，还有对接口扩展性的需求 因为在不同项目中，或者不同项目阶段中，可能会增加一些需求，需要扩展接口参数的。但如果接口参数太多，调用就可能会很长很麻烦。 所以会希望，接口有更强的扩展性，而且在不改动底层的情况增加接口就能实现需求。 回头一看好像是自己给自己挖坑啊。不过造轮子的，不都是自己找坑挖坑吗？ 分析完需求，我们就可以着手去设计接口了 接口设计一个简单的流程图 再看一张UML图 UI控制器的接口设计UI控制器的职责就是：实现UI逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 /** * 显示配置 */interface IShowConfig&lt; TypeKey extends keyof any = any, InitDataTypeMapType = any, ShowDataTypeMapType = any, &gt; &#123; typeKey?: TypeKey, /** * 透传初始化数据 */ onInitData?: InitDataTypeMapType[ToAnyIndexKey&lt;TypeKey, InitDataTypeMapType&gt;] /** * 强制重新加载 */ forceLoad?: boolean /** * 显示数据 */ onShowData?: ShowDataTypeMapType[ToAnyIndexKey&lt;TypeKey, ShowDataTypeMapType&gt;], /**在调用控制器实例onShow后回调 */ showedCb?: CtrlInsCb; /**控制器显示完成后回调 */ showEndCb?: VoidFunction; /**显示被取消了 */ onCancel?: VoidFunction, /**加载后onLoad参数 */ onLoadData?: any, /**加载完成回调,返回实例为空则加载失败，返回实例则成功 */ loadCb?: CtrlInsCb&#125;interface ICtrl&lt;NodeType = any&gt; &#123; key?: string | any; /**正在加载 */ isLoading?: boolean; /**已经加载 */ isLoaded?: boolean; /**已经初始化 */ isInited?: boolean; /**已经显示 */ isShowed?: boolean; /**需要显示 */ needShow?: boolean /**需要加载 */ needLoad?: boolean /**正在显示 */ isShowing?: boolean /** * 透传给加载处理的数据, * 会和调用显示接口showDpc中传来的onLoadData合并, * 以接口传入的为主 * Object.assign(ins.onLoadData,cfg.onLoadData); * */ onLoadData?: any; /**获取资源 */ getRess?(): string[] | any[]; /** * 初始化 * @param initData 初始化数据 */ onInit(config?: displayCtrl.IInitConfig): void; /** * 当显示时 * @param showData 显示数据 */ onShow(config?: displayCtrl.IShowConfig): void; /** * 当更新时 * @param updateData 更新数据 * @param endCb 结束回调 */ onUpdate(updateData: any): void; /** * 获取控制器 */ getFace&lt;T&gt;(): ReturnCtrlType&lt;T&gt;; /** * 当隐藏时 */ onHide(): void; /** * 强制隐藏 */ forceHide(): void; /** * 当销毁时 * @param destroyRes */ onDestroy(destroyRes?: boolean): void; /** * 获取显示节点 */ getNode(): NodeType;&#125; 这个接口不依赖任何引擎的接口和类。每个引擎项目实现对应的基类 管理器和业务不需要关注UI逻辑是怎么实现的，只需要调用接口并按照对外的数据接口传数据对象就可以了 onLoadData 这个是通用加载透传数据，比如：告诉通用加载逻辑显示什么加载等待界面 初始化接口onInit ，主要是用于实例化显示节点，监听UI交互事件等 显示接口onShow，主要是将UI显示并根据传入的数据进行渲染用 更新接口onUpdate，主要是根据传入的数据进行渲染更新 获取资源依赖接口 getRess，主要是通用资源处理逻辑需要获取UI界面依赖的资源信息进行加载/释放 其他的接口就很简单了，省略我重点讲一下，onShow这个接口的设计第一版的设计是1234/** * @param onShowData 调用时的透传数据 */onShow(onShowData?:any): void; 这样的设计，只能实现自定义透传显示数据的，但是要想实现管理逻辑的扩展而不改动onShow接口，就会非常麻烦 比如：我想扩展管理器，给UI控制传一个显示完成的回调：派发UI显示完成事件，让UI逻辑中动画播放完，或者其他延迟操作结束后调用。 那按照第一版的设计，那么只能加个参数：onShow(onShowData?:any,showEnd?:VoidFunction) 这个时候就是得修改ICtrl这个接口设计了。一个还可以，那如果变成了两个三个四个参数呢？就会变得复杂。现在的设计就可以解决这个问题，扩展透传的config参数的接口,不会增加接口参数，不改变接口 这个灵感来自axios这个库,一个易用、简洁且高效的http库 关于自定义资源处理实现 有自定义资源处理需求的UI控制器，需要实现这个接口123456789101112131415/** * 资源处理器 */interface IResHandler &#123; /** * 加载资源 * @param config */ loadRes?(config: displayCtrl.IResLoadConfig): void; /** * 释放资源 * @param ctrlIns */ releaseRes?(ctrlIns?: ICtrl): void;&#125; 那么管理器就会调用这个自定义的资源处理接口，而不是走通用的资源处理了 这样的接口设计可以说是在UI被管理的同时，给予了UI逻辑实现者极大的自由度，可以专注高效地实现和迭代，以及任意扩展 极大的自由度是有代价的，就是不能开箱即用。需要去实现接口，其实也很简单，所以这个是值得的。 具体的demo示例可以看:egf-ccc-full中的实现 继续讲UI管理器的设计 UI管理器的设计UI 管理器的职责就是:提供接口让业务去调用UI123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166interface IMgr&lt; CtrlKeyMapType = any, InitDataTypeMapType = any, ShowDataTypeMapType = any, UpdateDataTypeMapType = any&gt; &#123; /**控制器key字典 */ keys: CtrlKeyMapType; /** * 控制器单例字典 */ sigCtrlCache: CtrlInsMap; /** * 初始化 * @param resHandler 资源处理 */ init(resHandler?: IResHandler): void; /** * 批量注册控制器类 * @param classMap */ registTypes(classes: CtrlClassMap | CtrlClassType[]): void; /** * 注册控制器类 * @param ctrlClass * @param typeKey 如果ctrlClass这个类里没有静态属性typeKey则取传入的typeKey */ regist(ctrlClass: CtrlClassType, typeKey?: keyof CtrlKeyMapType): void; /** * 是否注册了 * @param typeKey */ isRegisted&lt;keyType extends keyof CtrlKeyMapType&gt;(typeKey: keyType): boolean; /** * 获取注册类的资源信息 * 读取类的静态变量 ress * @param typeKey */ getDpcRessInClass&lt;keyType extends keyof CtrlKeyMapType&gt;(typeKey: keyType): string[] | any[] /** * 获取单例UI的资源数组 * @param typeKey */ getSigDpcRess&lt;keyType extends keyof CtrlKeyMapType&gt;(typeKey: keyType): string[] | any[]; /** * 获取/生成单例显示控制器示例 * @param typeKey 类型key */ getSigDpcIns&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;(typeKey: keyType): displayCtrl.ReturnCtrlType&lt;T&gt; /** * 加载Dpc * @param typeKey 注册时的typeKey * @param loadCfg 透传数据和回调 */ loadSigDpc&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;(typeKey: keyType, loadCfg?: displayCtrl.ILoadConfig): displayCtrl.ReturnCtrlType&lt;T&gt;; /** * 初始化显示控制器 * @param typeKey 注册类时的 typeKey * @param initCfg displayCtrl.IInitConfig */ initSigDpc&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;( typeKey: keyType, initCfg?: displayCtrl.IInitConfig&lt;keyType, InitDataTypeMapType&gt; ): displayCtrl.ReturnCtrlType&lt;T&gt;; /** * 显示单例显示控制器 * @param typeKey 类key或者显示配置IShowConfig * @param onShowData 显示透传数据 * @param showedCb 显示完成回调(onShow调用之后) * @param onInitData 初始化透传数据 * @param forceLoad 是否强制重新加载 * @param onCancel 当取消显示时 */ showDpc&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;( typeKey: keyType | displayCtrl.IShowConfig&lt;keyType, InitDataTypeMapType, ShowDataTypeMapType&gt;, onShowData?: ShowDataTypeMapType[displayCtrl.ToAnyIndexKey&lt;keyType, ShowDataTypeMapType&gt;], showedCb?: displayCtrl.CtrlInsCb&lt;T&gt;, onInitData?: InitDataTypeMapType[displayCtrl.ToAnyIndexKey&lt;keyType, InitDataTypeMapType&gt;], forceLoad?: boolean, onLoadData?: any, loadCb?: displayCtrl.CtrlInsCb, onCancel?: VoidFunction ): displayCtrl.ReturnCtrlType&lt;T&gt;; /** * 更新控制器 * @param key UIkey * @param updateData 更新数据 */ updateDpc&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType, updateData?: UpdateDataTypeMapType[ToAnyIndexKey&lt;keyType, UpdateDataTypeMapType&gt;]): void; /** * 隐藏单例控制器 * @param key */ hideDpc&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): void; /** * 销毁单例控制器 * @param key * @param destroyRes 销毁资源 */ destroyDpc&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType, destroyRes?: boolean): void; /** * 实例化显示控制器 * @param typeKey 类型key */ insDpc&lt;T, keyType extends keyof CtrlKeyMapType = any&gt;(typeKey: keyType): ReturnCtrlType&lt;T&gt;; /** * 加载显示控制器 * @param ins * @param loadCfg */ loadDpcByIns(ins: displayCtrl.ICtrl, loadCfg?: ILoadConfig): void; /** * 初始化显示控制器 * @param ins * @param initData */ initDpcByIns&lt;keyType extends keyof CtrlKeyMapType&gt;( ins: displayCtrl.ICtrl, initCfg?: displayCtrl.IInitConfig&lt;keyType, InitDataTypeMapType&gt;): void /** * 显示 显示控制器 * @param ins * @param showCfg */ showDpcByIns&lt;keyType extends keyof CtrlKeyMapType&gt;( ins: displayCtrl.ICtrl, showCfg?: displayCtrl.IShowConfig&lt;keyType, InitDataTypeMapType, ShowDataTypeMapType&gt; ): void; /** * 通过实例隐藏 * @param ins */ hideDpcByIns&lt;T extends displayCtrl.ICtrl&gt;(ins: T): void; /** * 通过实例销毁 * @param ins * @param destroyRes 是否销毁资源 */ destroyDpcByIns&lt;T extends displayCtrl.ICtrl&gt;(ins: T, destroyRes?: boolean, endCb?: VoidFunction): void; /** * 获取单例控制器是否正在 * @param key */ isLoading&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean /** * 获取单例控制器是否加载了 * @param key */ isLoaded&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean; /** * 获取单例控制器是否初始化了 * @param key */ isInited&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean; /** * 获取单例控制器是否显示 * @param key */ isShowed&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean; /** * 获取控制器类 * @param typeKey */ getCtrlClass&lt;keyType extends keyof CtrlKeyMapType&gt;(typeKey: keyType): CtrlClassType&lt;ICtrl&gt;;&#125; 这里有一些TypeScript的类型编程魔法。可以实现及其强大的类型提示。看不懂的可以先忽略，先来讲一下接口设计 在设计这个UI管理接口时，一直念着：职责是管理UI，提供接口调用UI，不做多余的事情。为什么？因为脑子里总有很多功能想要塞进去，但其实都只是我想要的不必要的功能 所以设计得很克制，资源处理接口外包出去了，因为职责是管理UI，提供接口调用UI 什么栈式UI管理啊，也没有做，因为并不是所有项目都需要，只是特殊需求。 所有项目都需要的是：管理UI，提供接口调用UI。 既然讲到管理UI，那游戏开发中都有哪些UI呢？ 如果按具体的讲，各有各的说法，什么Dialog啊，Tips啊，Window啊等等,说不完的! 我抽象一下，按照同时存在多少个UI实例来分：只有两种类型的UI 单例UI 比如：通用加载界面，养成界面，角色展示界面，战斗界面等等，同时有且仅有一个实例存在 多实例UI 比如：奖励获得tips，属性提升tips 那业务逻辑通过UI管理器 调用显示UI，就是想如果有就直接显示出来，没有就加载创建一个来显示 调用显示n个UI，就是想创建n个UI同时显示不同的内容 这个抽象逻辑是我能想到的所有游戏项目都通用的逻辑。 那UI管理的接口设计就应该是：提供调用单例UI和多实例UI的接口。仅此 大家估计都看到了很多特殊的类型声明，下面我简单的讲一下这些类型声明的作用 类型提示优化如果想要更加舒适的接口调用体验，那么就必须榨干typescript的类型系统提供的能力（ps:有为什么不用？）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//displayCtrl.IMgrisLoading&lt;keyType extends keyof CtrlKeyMapType&gt;(key: keyType): boolean//实现UIimport &#123; BaseDpCtrl &#125; from \"./base-dp-ctrl\";declare global &#123; interface ITestCtrlKeyType &#123; OnUpdateDpc: \"OnUpdateDpc\", OnShowDpc: \"OnShowDpc\", OnInitDpc: \"OnInitDpc\" &#125; interface ITestCtrlShowDataMap &#123; OnShowDpc: number &#125; interface ITestCtrlInitDataMap &#123; OnInitDpc: number &#125; interface ITestCtrlUpdateDataMap &#123; OnUpdateDpc: number &#125;&#125;export class OnUpdateDpc extends BaseDpCtrl &#123; public static readonly typeKey: \"OnUpdateDpc\" = \"OnUpdateDpc\"; public updateData: number; constructor() &#123; super(); &#125; onUpdate(updateData: number) &#123; this.updateData = updateData; &#125;&#125;export class OnShowDpc extends BaseDpCtrl &#123; public static readonly typeKey: string = \"OnShowDpc\"; public showData: number; constructor() &#123; super(); &#125; onShow(config: displayCtrl.IShowConfig&lt;\"OnShowDpc\", ITestCtrlShowDataMap&gt;) &#123; this.showData = config.onShowData; super.onShow(config) &#125;&#125;export class OnInitDpc extends BaseDpCtrl &#123; public static readonly typeKey: \"OnInitDpc\" = \"OnInitDpc\"; public initData: number; constructor() &#123; super(); &#125; onInit(config: displayCtrl.IInitConfig&lt;\"OnInitDpc\", ITestCtrlInitDataMap&gt;) &#123; this.initData = config.onInitData; &#125;&#125;//实例化UI管理器const dpcMgr = new DpcMgr&lt;ITestCtrlKeyType,ITestCtrlInitDataMap,ITestCtrlShowDataMap,ITestCtrlUpdateDataMap&gt;();//注入类型ITestCtrlKeyType dpcMgr.init(&#123; loadRes: (config) =&gt; &#123; config.complete(); &#125; &#125;); dpcMgr.regist(OnUpdateDpc); dpcMgr.regist(OnInitDpc); dpcMgr.regist(OnShowDpc);//调用一个简单的dpcMgr.isLoading(\"\")//当双引号敲出，就会弹出类型提示选择:OnUpdateDpc，OnShowDpc，OnInitDpc//调用一个复杂的dpcMgr.showDpc(\"\")//当双引号敲出，就会弹出类型提示选择:OnUpdateDpc，OnShowDpc，OnInitDpc,//同时，需要传递onShowData时，也会有对应UIkey的onShowData类型提示dpcMgr.showDpc(\"OnShowDpc\",&#123;&#125;) 为什么要设计这样的类型提示？ 我想让UI逻辑实现者更加专注，只需要在顶部添加声明,业务逻辑调用就知道该传什么数据了。不用去翻找文件找接口 12345678910111213141516declare global &#123; interface ITestCtrlKeyType &#123; OnUpdateDpc: \"OnUpdateDpc\", OnShowDpc: \"OnShowDpc\", OnInitDpc: \"OnInitDpc\" &#125; interface ITestCtrlShowDataMap &#123; OnShowDpc: number &#125; interface ITestCtrlInitDataMap &#123; OnInitDpc: number &#125; interface ITestCtrlUpdateDataMap &#123; OnUpdateDpc: number &#125;&#125; 我想让UI调用者：业务逻辑，调用得更加舒服、无依赖、无import 关于typescript类型编程参考资料 编写TypeScript工具类型，你需要知道的知识 TypeScript 的工具类型 深入 TypeScript 的类型系统 TypeScript系列（三）从编程语言到Conditional Types 其他可能性虽然这篇文章讲的是UI管理框架 但其实我代码里和接口设计的方向并不限制只是UI管理，你可以用于管理各种抽象显示单位 UI只是其中一种，这个抽象显示单位可以是 一个小部件 主角 敌人 子弹 等等 它不只是UI框架，它是通用显示管理框架 总结关于UI框架的设计，提出UI业务实现中的两个本质的需求 高效、灵活且专注的UI逻辑实现 高效、灵活且高可扩展的UI管理 分析本质需求，提出更加细化的需求 根据需求设计和实现了一套跨引擎零依赖高效灵活高可扩展的UI框架。 适用于所有游戏引擎项目，可以根据自身需求任意扩展 并且通过研究typescript的类型编程，为接口调用提供了超级舒适的类型提示 具体的实现逻辑和CocosCreator2.4.2的demo，大家可以移步框架 GitHub仓库：EasyGameFrameworkOpen 希望大家可以给个star,谢谢~ 谢谢大家阅读我的文章~ 祝大家周末愉快~ 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 框架的诞生-二：定位 通用游戏UI框架的设计与实现 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 (欢迎前来讨论吹水) 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"},{"name":"分类2","slug":"框架设计/分类2","permalink":"http://yoursite.com/categories/框架设计/分类2/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/tags/框架设计/"}],"keywords":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"},{"name":"分类2","slug":"框架设计/分类2","permalink":"http://yoursite.com/categories/框架设计/分类2/"}]},{"title":"框架的诞生-二：定位","slug":"The-birth-of-the-framework-two-positioning","date":"2020-12-02T14:14:52.000Z","updated":"2020-12-03T14:49:55.313Z","comments":false,"path":"2020/12/02/The-birth-of-the-framework-two-positioning/","link":"","permalink":"http://yoursite.com/2020/12/02/The-birth-of-the-framework-two-positioning/","excerpt":"","text":"前几天发布了我的框架，EasyGameFramework ，也发了几篇文章来分享我的心得和想法。之后在跟一些小伙伴的交流中收获很多。初次写文章，有些地方可能没表达清楚，大家可能一些疑惑。所以想了一下，写了下这篇文章，主要讲一下关于这个框架的定位。 什么是定位？ 定位是一个汉语词汇，读音dìng wèi，意思是指确定方位，确定或指出的地方，确定场所或界限（如通过勘察）给这个地产的界限定位。出自《韩非子·扬权》。 第一篇文章 : 框架的诞生-零：为什么写框架？中有讲到，框架是解决特定领域问题的。 所以在这里我想要讲的定位是，如何划定框架解决问题的领域，以及方向。 为什么要定位呢？这里不得不提Vue这个框架，以及其作者尤雨溪尤大。我相信有很多人都认识。CocosCreator的编辑器所用的前端框架就是vue+Eletron。 这里有一篇对尤雨溪大佬的采访文章:比较详细的采访 Vue 作者尤雨溪，这篇采访中尤雨溪谈到了对vue的定位 在所有框架中，我自己创造了一个概念叫渐进的框架。因为 Vue 的核心组成只是数据绑定和组件，和 React 差不多。它只是解决了一小部分很重要的痛点。与 React 相比，Vue 可能更简单易用，只知道一些 HTML，JavaScript 和 CSS 知识的人都可以很快入门 Vue。 在框架层面上，我是用一个非常精简和尽可能小的的内核来构建的。但是当构建更复杂的应用的时候，有很多其他的问题需要解决。比如说路由，或者说怎么处理跨组件通信，怎么样在大型应用程序中共享状态，这样的话我们就还需要更多的构建工具来模块化我们的代码库。 怎么样来组织样式和各种各样的静态资源？像 Ember 或 Angular 这些非常完整的框架，它们就想解决所有可能遇到的这些问题，并把这些功能全都集成到框架中。 这就叫有得必有失吧。对用户使用情况的假设越多，框架最终的灵活性就越低。或者像 React 这样把很多问题都留给社区。React 社区是非常非常活跃的，经常有很多牛 X 的想法跳出来，当然也有不少不完美的想法。Vue 就是比较折中，仍然保持一个很小的核心，只提供一些最重要的功能。但是我们还是在逐渐提供一些更多的独立解决方案，比如说路由，状态管理，构建工具链和 CLI。它们都是官方维护的，有很好的文档，设计的也非常好，可以各种搭配使用，但重点是不需要的时候就可以不用。我认为这可能是 Vue 作为一个框架最大的特色。 就在今年Vue3.0也发布了，它在这条道路上更加极致了。有兴趣的小伙伴可以了解一下，掘金上也有很多分析的文章。 我对此的理解:渐进的框架，提供一个非常精简，尽可能小的内核。来满足基本需求。然后逐渐提供一些官方维护的帮助构建复杂应用的独立解决方案，可以各种组合搭配使用，不需要时可以不用。同时也可以自己开发定制自己的库。 一个框架需要有自己的定位，要么精简无比，就像react一样，就做个渲染库。或者像Angular一样，大而全。亦或者像vue一样折中，渐进。 一开始，我在慢慢搭建自己的框架时，心潮澎湃，激情满满。想要有很多很多功能，也实现了很多功能模块。但是，有时候想用一部分功能时，不好拆分，用了之后同步和维护也会变得麻烦。(ps.当时用Laya3d在开发rpg挂机项目，框架已经具备大部分功能模块了，也想开源出来，但想了想只是芸芸众轮中一个大同小异的轮子，没啥好分享的，也不好维护。) 大而全的路子不适合我，因为时间精力没那么多，而且价值和意义不大。 所以我选择了渐进。 这一个转变，让我更多地关注手中的业务，关注多人协作，以及对需求、问题的思考。去学习不同框架的设计思路，以及了解它们如何去解决它们界定的领域的问题。 我将我认为最重要最核心的模块分离出来，进行研究，实践和迭代，尽量打磨到更好的状态。 虽然我选择的方向和Vue相似，但不能比的。 框架核心的定位 极致轻量级 这样它就可以轻易融入任意阶段的项目，比如你想要一个舒服的全局调用不同模块的接口的体验，那它的添加几乎无感，就130多行的源码，未压缩就10kb。 引擎无关性 不受限于任意引擎，只要是能用js/ts开发的程序，都可以用。如果你希望获得在不同项目中拥有一致的编码和模块管理体验的话。 可插拔可扩展的模块化机制 核心库提供的机制，可以让你可以创造多种方式去管理你的业务和基础模块，你可以在里面套pureMvc那套规范，也可以简单的横向扩展。使用面向接口编程，你可以动态地根据平台，环境，替换具体模块实现。 灵活可扩展的模块生命周期 模块生命周期可以方便管理模块之间的依赖，以及可以扩展自己业务环境所需的生命周期。 比如登陆，登陆之后，断线，重连，屏幕尺寸变化，进入后台，要做引导了…等等 论坛上有个小伙伴@zzzz.leung问到我 模块之间的依赖怎么处理呢？一个框架应该需要提供模块裁剪能力以减少代码包大小吧？因为迭代的功能越多，框架会越庞大复杂。 其实这个模块生命周期的用法在框架的诞生-一：我想要的框架就有说到，不知道是不是你想要的。 start, afterStart 这些生命周期 接口跟 cocos 和 Unity 的组件式接口很像。 主要是方便处理不同模块之间的依赖引用。比如：A 依赖了 B，但 B 还未初始化。 各自的初始化，都在 start 里处理，然后在 afterStart 里进行依赖调用。 可能对于不同的业务，这些生命周期可能不够用，可以根据具体业务进行扩展，满足自定义需求。 比如登录业务相关的： C 模块依赖 A 和 B 登录后的数据状态，那么增加两个接口 onLoginInit,onAfterLoginInit。 那么 A 和 B 实现 onLoginInit 接口进行登录初始化，C 在 onAfterLoginInit 接口进行依赖调用。 模块自动裁剪这种功能，太高级了。这个是在编译层做的处理，比如摇树Treeshake优化，将没有调用过的函数代码剪掉。 随着功能迭代开发，框架的确会越来越庞大，这个时候就需要开发者自己去整理了，这个可能任何框架都没办法帮你自动处理。有人可能说:人家CocosCreator可以啊。这个是官方提供的对引擎的模块进行剔除。你自己扩展一堆模块，可能需要你自己去决定剔除哪些了。同样，我所提供的模块，你可以按需使用。 可以参照这两张图▼ 我提供的一些模块有我个人从业务开发中实践然后沉淀比如显示管理模块display-ctrl，也有我基于兴趣写的，比如imgui编辑器开发库。 框架库构建工具的定位 用于导出多模块规范的typescript库 可以做nodejs工具开发，通用库开发，引擎扩展库开发、、、 其实这个平时的业务开发不推荐使用这个工具将模块，独立起来开发。只有当这个模块需要多项目内共用，开源分享，抽离沉淀时使用。因为会增加维护成本。平时开发怎么方便就怎么来。 EasyGameFramework仓库的定位开源和持续维护这个项目主要是开源和持续维护框架提供的一些重要的基础模块。 包括不仅限于 前端基础模块（显示，资源，消息状态，网络等） 引擎扩展模块 基础模块的引擎实现 抛砖引玉给大家提供一个开发框架的实践参考，也方便大家交流框架开发，业务开发等 也鼓励更多的人参与和交流，游戏开发路上不孤单。 H5游戏技术中台实践参考这个说的有点夸张，但意思是那个意思，就是沉淀技术进行多项目共享的实践 游戏引擎，属于游戏程序里的渲染层级，如果能将业务和渲染很好的分离，将业务和渲染扩展分别沉淀，不仅有益于提高现有项目的开发效率。而且将来如果做下一个项目，甚至切换引擎做项目，那么这个沉淀就可以让我节省很多时间，花更多的时间来专注业务和游戏性逻辑的研发，提高项目开发效率。 如果用了fairygui这种第三方UI解决方案，连UI资产也可跨项目跨引擎，那也可以节省很多时间。 当然也可以参照这个项目去打造公司的技术中台。 如果想做一个免费私有的npm源，可以借助coding免费打造私有的制品库。感兴趣的可以了解一下CODING 制品库 | 版本化的制品管理 这个项目是基于monorepo，主要是为了方便多模块项目开发和共享。 了解一下monorepo资料 白鹭的egret pro 就是使用了monorepo的方式进行开发。 【PPT】白鹭引擎首席架构师@王泽：框架开发中的基础设施搭建 ▼ 当然这个好不好用，看个人和团队。 我自己使用的感觉就是，多个独立模块同时开发，一个包写完代码，另一个包就可以像npm install 之后那样用，反馈非常快，非常舒服。 就是指令稍微有点复杂这个不太舒服，开发久了就习惯了 如果是分开仓库，本地开发还好，可以使用npm link，但如果多人协作，就麻烦了。 而且本地开发需要npm link 这个和install不太一样，就是和具体的使用环境不同。 谢谢大家阅读我的文章，希望大家能有所收获。 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 框架的诞生-二：定位 不只是 UI 管理:通用显示管理 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/tags/框架设计/"}],"keywords":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}]},{"title":"打破CocosCreator3d不能使用npm包的魔咒!!!","slug":"Break-the-spell-that-CocosCreator3d-cannot-use-NPM-packages","date":"2020-11-30T14:36:20.000Z","updated":"2020-11-30T16:00:29.540Z","comments":false,"path":"2020/11/30/Break-the-spell-that-CocosCreator3d-cannot-use-NPM-packages/","link":"","permalink":"http://yoursite.com/2020/11/30/Break-the-spell-that-CocosCreator3d-cannot-use-NPM-packages/","excerpt":"","text":"背景 我在开发EasyGameFramework这个框架的时候，目标之一是构建出来的模块包可以在CocosCreator3D上使用，使用体验和正常使用具有类型声明的Npm包一致。实在不行再用发布源码的方式。 在js生态中npm有很多很强大很有用的模块包 论坛上也有小伙伴对在CocosCreator3d上使用npm包有需求。 但CocosCreator3D的模块机制和CocosCreator不同，所以暂不支持直接使用npm包。 那怎么办呢？首先了解一下CocosCreator3d模块机制 CocosCreator3d模块机制这个时候就得祭出调试的杀手级工具:Chrome Devtools 调试运行CocosCreator3d空项目查看index.html CocosCreator3d中使用了system.js，并且在index.html注册了一个叫 code-quality:cr的模块 而且加载了一个.import-map.json的东西 搜索.import-map.json看看是什么 通过以上的调试我们大概知道，CocosCreator3d使用了一个叫systemjs的库，然后呢，用来注册一些模块。这个systemjs可能是关键的东西，得了解一下。 SystemJS的官方github:https://github.com/systemjs/systemjs 别人的使用:SystemJS使用记录 了解过后，我们能知道它就是一个模块加载器，以及它的注册方式 通过一个map注册一堆模块 通过register接口注册一个模块 但是怎么处理引用的呢？ 断点调试systemjs找到systemjs，搜索register 搜索importMap之类的关键词 通过以上调试验证了我们的猜想：SystemJs，用来注册和加载模块的，是一种模块规范，需要做特殊处理才能注册进去和使用。但我们需要来写一个简单的systemjs规范的模块来验证一下。 手写一个简单的SystemJs的模块 simple-sysjs.js 12345678910111213System.register('simple-sysjs', [], function (exports) &#123;'use strict'; return &#123; execute: function () &#123; var SimpleSysJs = exports('SimpleSysJs', /** @class */ (function () &#123; function SimpleSysJs() &#123; console.log(\"我是简单的systemjs模块\") &#125; return SimpleSysJs; &#125;())); &#125; &#125;;&#125;); 声明文件:simple-sysjs.d.ts 1234declare module 'simple-sysjs' &#123;export class SimpleSysJs &#123; &#125;&#125; 为了保证这个脚本优先于其他脚本加载，将simple-sysjs.js设置为插件 然后在编辑器新建脚本，写下 12import &#123; SimpleSysJs &#125; from \"simple-sysjs\"new SimpleSysJs() 运行后可以看到输出:我是简单的systemjs模块 这个很简单的，大家都可以新建一个空C3d项目尝试一下。 经过验证尝试，我们知道，只要将npm包转成systemjs规范的文件就可以被我们的代码引用，以及正常使用了。但手写太麻烦了，有什么简单的办法呢？ 如何快速地转换npm包为systemjs规范库使用egf-cli这个工具是我为EasyGameFramework打造的，目的是可以发布框架库为任意规范模块，给不同的引擎和项目使用。 有兴趣可以看看我之前写的文章 框架的诞生-一：我想要的框架 以及框架仓库:https://github.com/AILHC/EasyGameClientFramework.git 使用这个工具对npm包有一定的要求 符合commonjs规范 最好有类型声明文件 最好能是typescript开发的 我以xstate（一个高star的状态机库）为例子 c3d项目下安装 xstate ,npm i xstate 然后复制 EasyGameFrameOpen的package-template项目 修改包名为 1\"name\": \"@ailhc/xstate2c3d\", 修改构建命令为 1\"build:system\": \"egf build -f system:@ailhc/xstate2c3d\", 删除其他ts文件，留下index.ts 然后写一句: 1export * from \"xstate\" 最后执行 yarn run build:system 最后的最后，因为xstate里引用了node的变量，所以在构建出来的index.js要加一句 12345sendParent: sendParent,sendUpdate: sendUpdate,spawn: spawn &#125;);var process = &#123; env: &#123; NODE_ENV: \"production\" &#125; &#125; 复制lib和types到c3d项目，将index.js设置为插件 在任意脚本引用就可以 1234567891011121314151617181920212223import &#123; createMachine, interpret &#125; from \"@ailhc/xstate2c3d\"// Stateless machine definition// machine.transition(...) is a pure function used by the interpreter.const toggleMachine = createMachine(&#123; id: 'toggle', initial: 'inactive', states: &#123; inactive: &#123; on: &#123; TOGGLE: 'active' &#125; &#125;, active: &#123; on: &#123; TOGGLE: 'inactive' &#125; &#125; &#125;&#125;);// Machine instance with internal stateconst toggleService = interpret(toggleMachine) .onTransition((state) =&gt; console.log(state.value)) .start();// =&gt; 'inactive'toggleService.send('TOGGLE');// =&gt; 'active'toggleService.send('TOGGLE');// =&gt; 'inactive' xstate2c3d的工程已经更新到EasyGameFrameOpen：https://github.com/AILHC/EasyGameFrameworkOpen.git 其他方式 如果npm包有构建systemjs，直接使用 如果没有构建systemjs，看是否有typescript源码，copy源码，使用egf-cli构建一个systemjs规范的js 如果是全局变量的库，直接设置为插件就可以了。 CocosCreator3.0?它也许会支持npm包，但等待它的到来可能还有一段时间 而且研究一下CocosCreator3d的模块加载机制说不定，在遇到看不懂的问题时有所头绪呢。 谢谢大家阅读我的文章，希望大家能有所收获。 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 不只是 UI 管理:通用显示管理 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"EasyGameFramework使用","slug":"EasyGameFramework使用","permalink":"http://yoursite.com/categories/EasyGameFramework使用/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"CocosCreator3d","slug":"CocosCreator3d","permalink":"http://yoursite.com/tags/CocosCreator3d/"}],"keywords":[{"name":"EasyGameFramework使用","slug":"EasyGameFramework使用","permalink":"http://yoursite.com/categories/EasyGameFramework使用/"}]},{"title":"框架的诞生-一：我想要的框架","slug":"The-Birth-of-a-Framework-One-The-Framework-I-Want","date":"2020-11-29T09:23:49.000Z","updated":"2020-12-20T04:02:38.529Z","comments":true,"path":"2020/11/29/The-Birth-of-a-Framework-One-The-Framework-I-Want/","link":"","permalink":"http://yoursite.com/2020/11/29/The-Birth-of-a-Framework-One-The-Framework-I-Want/","excerpt":"","text":"目录[TOC] 我想要的框架是什么样的？ 上一篇文章: 《框架的诞生-零：为什么写框架？》里有讲 什么是框架。 框架是一个架子，在游戏程序中，抛开渲染层引擎框架，我们的指的框架就是支撑业务逻辑的架子，也是一个框框，规范和约束着开发人员。 每个框架都有着自己的边界，解决特定领域问题的。 那我们从去分析我遇到了什么问题，有什么需求，如何解决问题，如何实现需求。 无论是小项目还是大项目，或者是一个会不断扩张的项目，都希望能够项目代码结构清晰有条理，管理好不同模块。 我尝试过的方式Manager of Managers很多框架都用这种方式（包括我之前写的框架） 这是刘钢老师的《Unity 项目架构设计与开发管理》中讲到的一种相对较好的方式 ▼ 优点是:类似于分级结构，各司其职；比如音频管理，场景管理，关卡管理等，每一个都是一个单例脚本，配合使用。结构相对清晰。可以复用 但我个人不太喜欢的点 调用不方便，调用链太长，费手指。比如 UIManager.getInstance().showUI 或者 UIMgr.ins.showUI 我想这样: m.uiMgr.showUI 少敲几个字母，也不想 import UIMgr 无生命周期统一管理，单例初始化和依赖不太可控。惰性初始化，等到调用 getInstance 才初始化。 控制台调试调用不方便，单例可能得单独绑定暴露到全局才能，每个模块都得这样做才行 直接依赖不可动态替换 有个模块我想在不同的平台切换成不同的实现，单例做不到。 大多耦合引擎来开发，只能在同引擎项目进行复用 模块字典挂载到全局变量 window这是我之前的框架使用的方式 就是将所有的模块初始化，然后注入一个模块字典 然后将字典挂载到全局的一个变量中。 1234567891011121314151617export class Main &#123; constructor()&#123; const moduleMap = &#123; &#125;; moduleMap[\"uiMgr\"] = new UIMgr(); moduleMap[\"netMgr\"] = new NetMgr(); window[\"aa\"] = moduleMap; &#125;&#125;class UIMgr &#123;&#125;class NetMgr &#123;&#125; 优点：调用方便 缺点: 有点危险，别人知道了可以在控制台调用进行调试。 这些方式在模块管理上都有问题，先不考虑如何方便调用，先实现个如何管理模块的核心机制。 一个具有生命周期的模块化机制pomelo 给我的灵感这个想法的灵感来自 pomelo 一个网易开发的基于 nodejs 的分布式服务器框架。 pomelo 支持可插拔的 component 扩展架构 用户只要实现 component 相关的接口： start, afterStart, stop, 就可以加载自定义的组件： 1app.load([name], comp, [opts]) start, afterStart 这些生命周期 接口跟 cocos 和 Unity 的组件式接口很像。主要是方便处理不同模块之间的依赖引用。比如：A 依赖了 B，但 B 还未初始化。 各自的初始化，都在 start 里处理，然后在 afterStart 里进行依赖调用。 可能对于不同的业务，这些生命周期可能不够用，可以根据具体业务进行扩展，满足自定义需求。 比如登录业务相关的： C 模块依赖 A 和 B 登录后的数据状态，那么增加两个接口 onLoginInit,onAfterLoginInit。 那么 A 和 B 实现 onLoginInit 接口进行登录初始化，C 在 onAfterLoginInit 接口进行依赖调用。 怎么实现我想要的框架？模块生命周期图 ▼ 接口设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778declare global &#123; namespace egf &#123; interface IModule &#123; /**模块名 */ key?: string /** * 当初始化时 */ onInit?(app: IApp): void; /** * 所有模块初始化完成时 */ onAfterInit?(app: IApp): void; /** * 模块停止时 */ onStop?(): void; &#125; type BootEndCallback = (isSuccess: boolean) =&gt; void; /** * 引导程序 */ interface IBootLoader &#123; /** * 引导 * @param app */ onBoot(app: IApp, bootEnd: BootEndCallback): void; &#125; /** * 主程序 */ interface IApp&lt;ModuleMap = any&gt; &#123; /** * 程序状态 * 0 未启动 1 引导中, 2 初始化, 3 运行中 */ state: number; /** * 模块字典 */ moduleMap: ModuleMap; /** * 引导 * @param bootLoaders */ bootstrap(bootLoaders: egf.IBootLoader[]): Promise&lt;boolean&gt;; /** * 初始化 */ init(): void; /** * 加载模块 * @param module */ loadModule(module: IModule | any, key?: keyof ModuleMap): void; /** * 停止 */ stop(): void; /** * 获取模块实例 * @param moduleKey */ getModule&lt;T extends IModule = any&gt;(moduleKey: keyof ModuleMap): T; /** * 判断有没有这个模块 * @param moduleKey */ hasModule(moduleKey: keyof ModuleMap): boolean; &#125; &#125;&#125;// eslint-disable-next-line @typescript-eslint/semiexport &#123; &#125; Bootloader: CatLib 给我的灵感这里有一个 bootloader 的东西我没有讲到，它的灵感来自 CatLib，一个我觉得很棒的 Unity 框架。 这个机制是什么呢？以开发测试环境和生产环境举例。 有一个 debugBootLoader，这个引导程序处理一些测试用的模块加载和初始化，杂七杂八的。 当你发布生产环境时，可以通过 debug 变量屏蔽加载这个引导程序，也可以通过编译工具剔除这段代码。 具体实现可以看：https://github.com/AILHC/EasyGameFrameworkOpen/tree/main/packages/core#readme 怎么使用?具体使用请看 demo 工程 cocoscreator2.x 的 demo https://github.com/AILHC/egf-ccc-empty cocoscreator3d 的 demo https://github.com/AILHC/egf-ccc3d-empty 如何接入项目▼ 1234567891011121314151617181920212223242526272829303132//FrameworkLoader.tsimport &#123; HelloWorld &#125; from \"../HelloWorld\";export class FrameworkLoader implements egf.IBootLoader &#123; onBoot(app: egf.IApp, bootEnd: egf.BootEndCallback): void &#123; const helloWorld = new HelloWorld(); app.loadModule(helloWorld); bootEnd(true); &#125;&#125;//AppMain.tsimport &#123; App &#125; from \"@ailhc/egf-core\"import &#123; FrameworkLoader &#125; from \"./boot-loaders/FrameworkLoader\";import &#123; setModuleMap, m &#125; from \"./ModuleMap\";/** * 这是一种启动和初始化框架的方式，在cocos加载脚本时启动 * 不依赖场景加载和节点组件挂载 */export class AppMain &#123; public static app: App&lt;IModuleMap&gt;; public static initFramework() &#123; const app = new App&lt;IModuleMap&gt;(); AppMain.app = app; app.bootstrap([new FrameworkLoader()]); setModuleMap(app.moduleMap); app.init(); window[\"m\"] = m;//挂在到全局，方便控制台调试，生产环境可以屏蔽=&gt;安全 m.helloWorld.say(); &#125;&#125;AppMain.initFramework(); 接入项目很简单，new 一下，bootstrap，init 就可以了~ 注入模块也很简单 12345678//在UIMgr.ts开头增加个声明declare global &#123; interface IModuleMap &#123; uiMgr:UIMgr &#125;&#125;//在初始化地方，注入实例app.loadModule(UIMgr.getInstance(),\"uiMgr\"); 注入的模块是什么类型的，不限制，你可以将业务模块 比如 HeroModule 注入进去，那么业务模块之间就可以直接调用了。也不用担心 typescript 的循环引用了。 举个栗子（随便的）: 12345// BattleModule.tsm.hero.showHero(1);//HeroModule.tsm.battle.startTestBattle(1); 就像服务端的 rpc 调用一样。 12app.rpc.chat.chatRemote.kick(session, uid, player, function(data)&#123;&#125;); 至于怎么使得接口调用更方便，这个看个人的喜好，我呢，用了一点点魔法，让自己用着舒服又有点安全感。具体实现细节请看 demo 我想在 CocosCreator 和 C3d 中使用由于我的工作中是用 Laya 的，项目也用了这个框架。但我私底下都是玩 CocosCreator 和 CocosCreator3d 的(为什么啊？你懂得 😉😉) 我不想在项目之间将源码拷贝来拷贝去，迭代更新同步麻烦。 如果能像 npm 包一样 安装就好了。而且核心模块是一个模块，其他模块也是一个模块。 于是我开发了一个模块编译发布的工具，开发之前以为很简单，实际上，踩坑了好久 😂。 这个模块编译发布工具有什么功能？ 编译模块成 iife、commonjs、systemjs 格式的 js 文件 自动生成单个.d.ts 声明文件 这个 systemjs 格式的 js 文件可以让不支持 npm 包的 CocosCreator3d 可以像使用 npm 包一样使用。即使到时 Cocos3.0 支持 npm 了，使用方式也一模一样。使用 C3d1.2.0 发布 web，微信小游戏，验证运行没有问题。 123456789101112131415161718192021222324252627282930313233import &#123; App &#125; from '@ailhc/egf-core';//像引用npm包一样引用import &#123; _decorator, Component, Node &#125; from 'cc';import &#123; m, setModuleMap &#125; from './ModuleMap';import &#123; FrameworkLoader &#125; from './boot-loaders/FrameworkLoader';const &#123; ccclass, property &#125; = _decorator;@ccclass('AppMainComp')export class AppMainComp extends Component &#123; /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; onLoad() &#123; this._initFramework(); &#125; private _initFramework() &#123; const app = new App&lt;IModuleMap&gt;(); // new TestImport(); app.bootstrap([new FrameworkLoader()]); // app.bootstrap([new FrameworkLoader2()]); setModuleMap(app.moduleMap); app.init(); window[\"m\"] = m;//挂在到全局，方便控制台调试，生产环境可以屏蔽=&gt;安全 m.helloWorld.say(); &#125; start() &#123; &#125; // update (dt) &#123;&#125;&#125; 如何开发一个模块 克隆项目 git clone https://github.com/AILHC/EasyGameFrameworkOpen.git 复制 packages/package-template 项目，改文件夹名，改 package.json 里的项目名等信息 npm install 初始化项目 然后用 typescript 进行开发，使用 index.ts 文件将所有代码 export（可以使用 export-typescript 插件自动化，插件版本必须是 0.0.5 之前的） 使用 egf build 进行编译发布 总结一下框架有什么特性 轻量级模块化机制 模块生命周期 让模块的初始化有序，依赖可控 可面向接口编程 方便具体实现细节可替换，模块可动态替换 友好的类型声明 点一下就有类型提示，传字符串获取模块也有类型提示，很香的。 基于 TypeScript 与引擎无关 每个模块库都是一个 npm 包 模块库可以导出多种 js 格式，让 laya，ccc，c3d 使用，甚至给 Unity、Unreal 用(xLua 作者的 Puerts 了解一下？) 这个框架可以做什么？特性 基于轻量级无依赖的模块机制，可以为不同项目量身定制框架，可大可小。也可以根据项目的不同阶段进行渐进式扩展。还可以在项目的不同阶段轻易地接入 面向接口编程的模块，底层组件可以无感知替换 基于模块开发工具，我们可以开发和发布一个单独的对核心零依赖的模块，给不同的项目使用。 方便别的项目引用 方便开源 方便做单元测试 基于模块化机制和配套开发工具，大家可以为公司或者个人建立自己的模块库，在不同项目按需复用。 架构设想 ▼ 谢谢大家阅读我的文章，希望大家能有所收获。 谢谢大家阅读我的文章，希望大家能有所收获。 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 框架的诞生-二：定位 不只是 UI 管理:通用显示管理 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/tags/框架设计/"}],"keywords":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}]},{"title":"框架的诞生-零：为什么写框架？","slug":"The-Birth-of-Frames-Zero：Why-write-framework","date":"2020-11-17T07:53:39.000Z","updated":"2020-12-02T15:53:36.739Z","comments":false,"path":"2020/11/17/The-Birth-of-Frames-Zero：Why-write-framework/","link":"","permalink":"http://yoursite.com/2020/11/17/The-Birth-of-Frames-Zero：Why-write-framework/","excerpt":"","text":"目录[TOC] 题外话大家好，很高兴，能写这篇文章分享给你们看，也很感谢你们能看我的文章。如果能和你们交流最好了。做游戏开发3、4年了，我用过这些，Unity，Cocos2dx，CocosCreator，LayaAir，Egret。 用得最久的是LayaAir，因为工作需要嘛。 但最喜欢的还是CocosCreator，因为社区的小伙伴、引擎组的人都很好很可爱，他们分享的东西都让我受益匪浅。 谢谢~ 第一次写文章，如有不当之处请多多见谅。 什么是框架？我想有的人心里有答案，有的人也有疑问。 这里我提供别人对框架的见解链接: 某乎文章:什么是框架？为什么要使用框架？我告诉你理由哦！ 123框架的英文为Framework意思是框架、机制、准则。最早是源于建筑行业，是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。 @金戈的回答: 什么是框架？ 123框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。IT语境中的框架，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构。在此结构上可以根据具体问题扩展、安插更多的组成部分，从而更迅速和方便地构建完整的解决问题的方案。 我的个人见解：▼ 我们的游戏程序都是基于某个平台的，以及可能会使用现成的渲染框架，来实现我们游戏的玩法和业务。同时针对开发和生产环境部署，我们需要一些工具协助。 框架在渲染框架层和业务层之间，封装部分通用能力供业务层使用。起到支撑业务开发的作用。 我的层级图的灵感来自 @白玉无冰 大佬拍的panda大大讲的一页一个PPT:CocosCreator跨平台的引擎架构。▼ 对于游戏客户端框架来说 框架具有一定的约束性，指的是，我们需要在一定范围内按照框架作者的设计和规范去使用和扩展。 比如： 在CocosCreator框架中。 如果要加载一个资源，那就需要调用cc.assetManager.loadxxx 或者cc.loader.loadxxx，传规定的参数，传错了就可能出问题。 如果需要加载自定义的资源就需要安装assetManager的规范去扩展。具体可参考CocosCreator的文档，不按规范扩展就可能出问题。 框架有部分已经实现的功能，可以直接使用或者稍微扩展就可以用来实现业务逻辑。 大部分游戏客户端框架都包含很多功能模块，甚至不是我们项目需要的。 比如： 框架中包含UI管理框架，事件通讯框架，网络模块，等等。 我们可能只需要事件通讯模块或者UI管理模块，只能手动去剔除不需要的。 框架所能解决的问题有限，有边界。 比如： 有的框架只是一个UI管理框架只解决了复杂UI管理的问题 框架可能跟底层强相关。 比如：一个基于CocosCreator的UI管理模块，里面耦合了CocosCreator的加载，prefab文件，resource文件夹的规范等，可能也耦合了cc.Node的使用等等。 框架解决什么问题？大家对框架的第一印象可能是 我学不动了 提高开发效率，快！！！ 我个人觉得好坏还得看框架和看个人 好的框架可以统一多个开发人员的编程风格，方便多人协作 好的框架可以让开发人员减少维护程序架构心智负担，减少纠结。 最重要的是可以大大的提高开发效率，大部分时间专心写业务就可以了。 为什么写框架？为了造一个更好更适合的轮子有现成的框架为什么不拿来直接用，干嘛自己造轮子浪费时间？ 现成的框架没法满足需求，有无法解决的问题。 现成的框架和自己的思想不符。 为了学习和实践写框架可以督促我去学习其他框架是如何设计的，为什么这样设计，能解决什么问题，为什么能解决这些问题。 然后反过来去思考我工作和开发中遇到的问题，我学着去分析，去尝试找解决方案，以及思考如果我写框架怎么解决这些问题。怎么去设计。 写出来的框架很挫怎么办？怕个毛线，继续学习，继续思考，然后解决问题，大不了推翻重写。 写出来的框架不能用在公司的项目中去实践怎么办？这个想法有点危险，哈哈哈，可以自己写项目来验证。不过还有另外一种解决方案。下一篇会讲。 写框架是一场历练，督促着我去学习和沉淀所学，打磨我的知识体系，让它更加完善。 总结 什么是框架？是游戏程序的一部分，是支撑游戏业务逻辑的架子，但也是具有一定约束的框框。 框架解决什么问题？ 可以统一多开发人员的风格（框架的风格） 可以让开发人员减少维护程序架构的心智负担，减少纠结（按照框架的思想来就行） 可以大大提高开发效率，大部分时间专心写业务逻辑就可以了 为什么写框架？ 去学习其他框架怎么设计，怎么解决它们面对的问题。 解决自己工作和开发中遇到的问题 积累和沉淀自己的知识 一些游戏客户端框架参考 CatLib 一个Unity的渐进式框架(ps：我的框架灵感之一) U3d网络游戏架构设计 一个大佬的GitChat专栏，需要订阅 腾讯学院的手游核心技术实战 这是腾讯学院的一个贪吃蛇大作战的一个游戏开发课程，讲到了如何设计和实现基于Unity的游戏框架 GameFramework 基于Unity的一个完善的框架 QFramework 基于Unity的一个完善且扩展性非常强的框架，而且作者有很多关于框架设计的理念，非常棒 UNITE －Unity项目架构设计与开发管理 文章：Unity项目架构设计与开发管理 【ituuz分享-框架】lightMVC:轻量级游戏开发框架(for cocos creator) GameplayFrameWork for CococsCreator 其他的还有很多，论坛搜 “框架”即可 心里话我想和优秀的小伙伴一起开发好玩的游戏 我希望能通过我做的游戏，我的能力获得用于生活和学习的报酬。 我也希望 有人能从我的游戏中获得快乐，或者有所收获 也希望 有人能因我的分享而有所收获 然后我能说一句 谢谢你玩我的游戏 谢谢你信任我 谢谢你用我的框架 谢谢大家阅读我的文章，希望大家能有所收获。 框架开发系列文章 框架的诞生-零：为什么写框架？ 框架的诞生-一：我想要的框架 打破CocosCreator3d不能使用npm包的魔咒!!! 框架的诞生-二：定位 不只是 UI 管理:通用显示管理 让 fairygui 更好用的插件 满足多种需求的通用对象池 构建游戏/应用的神器:broadcast 满足所有自定义需求的通用 socket 网络模块 业务开发总结之状态管理 待续。。。 最后欢迎关注我的公众号，更多内容持续更新 公众号搜索:玩转游戏开发 或扫码: QQ 群: 1103157878 博客主页: https://ailhc.github.io/ 掘金: https://juejin.cn/user/3069492195769469 github: https://github.com/AILHC","categories":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}],"tags":[{"name":"EasyGameFramework","slug":"EasyGameFramework","permalink":"http://yoursite.com/tags/EasyGameFramework/"},{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/tags/框架设计/"}],"keywords":[{"name":"框架设计","slug":"框架设计","permalink":"http://yoursite.com/categories/框架设计/"}]},{"title":"命令行使用记录","slug":"about-terminal-and-shell","date":"2020-03-08T07:02:40.000Z","updated":"2020-10-17T06:49:00.935Z","comments":false,"path":"2020/03/08/about-terminal-and-shell/","link":"","permalink":"http://yoursite.com/2020/03/08/about-terminal-and-shell/","excerpt":"","text":"在Mac上配置命令行工具使用 iTerm2 + zsh 参考资料 关于homebrew的安装 Mac下终端工具iTerm2安装在windows配置命令行工具使用 使用Cmder 参考资料 Windows终端利器Cmder","categories":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"}],"tags":[{"name":"terminal","slug":"terminal","permalink":"http://yoursite.com/tags/terminal/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}],"keywords":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"}]},{"title":"写作输出记录","slug":"how-to-wrrite-blog","date":"2020-02-28T01:52:16.000Z","updated":"2020-10-17T06:49:00.938Z","comments":true,"path":"2020/02/28/how-to-wrrite-blog/","link":"","permalink":"http://yoursite.com/2020/02/28/how-to-wrrite-blog/","excerpt":"","text":"写作输出记录个人博客 搭建参考 hexo史上最全搭建教程 hexo 官网文档 使用hexo+github搭建免费个人博客详细教程 使用Markdown写作 有道云笔记可以写Markdown笔记，然后copy到hexo个人博客仓库 也可以使用vscode直接写markdown markdown使用参考: 为什么要学Markdown？有什么用？ 各个平台 自媒体平台,参考：自媒体有哪些平台？ 博客平台 CSDN 简书 博客园 个人公众号 如何将markdown笔记发布到各个平台 使用Md2All转富文本 :Md2All 直接复制markdown笔记","categories":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"}],"tags":[{"name":"写作","slug":"写作","permalink":"http://yoursite.com/tags/写作/"},{"name":"输出","slug":"输出","permalink":"http://yoursite.com/tags/输出/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}],"keywords":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"}]},{"title":"Git使用记录","slug":"git-use-record","date":"2020-02-27T13:04:35.000Z","updated":"2020-10-17T06:49:00.937Z","comments":true,"path":"2020/02/27/git-use-record/","link":"","permalink":"http://yoursite.com/2020/02/27/git-use-record/","excerpt":"","text":"Git 使用记录Git学习资源Git问题记录SSHKey 怎么生成？ 123ssh-keygen -t rsa -C &quot;youremail&quot;默认会生成 名字 id_rsa 的sshkey 可以自己自定义,但再使用时可能会有问题 关于错误:ssh: Could not resolve hostname github.com: Name or service not known.fatal: Could not read from remote repository.参考解决方案: 在Github中使用 1234Settings-&gt;SSHKey -&gt; NewSSHKey将 id_rsa.pub(公钥) 文件的内容复制进去然后在git bash 执行:ssh -T git@github.com “执行:ssh -T git@github.com“ 出现Permission denied (publickey)参考解决方案 如果在创建sshkey时使用自定义文件名, 执行 ssh-add ~/.ssh/&lt;自定义sshkey名&gt; 可能会出现：Could not open a connection to your authentication agent 参考解决方案 文件名大小问题 缘由：原来的文件名是小写的文件，复制了大写的文件名文件，显示覆盖，但覆盖后，文件名还是小写的 解决方案： 参考：git 大小写问题 踩坑笔记 在项目目录下执行命令： 123touch .gitconfiggit config core.ignorecase falsegit config --global core.ignorecase false Git二进制文件管理以及如何git瘦身缘由在游戏开发过程中，会使用用到很多二进制类资源，比如 图片，配置压缩文件，3d资产文件等，由于git的工作原理，不断的commit会不断的累加。整个仓库会变得非常庞大。 二进制文件管理 参考资料a. Git 管理实战（五）：二进制大文件的版本控制b. Git LFS的使用c. 百度 git lfsgit 瘦身实践 参考资料a. Git清理删除历史提交文件https://www.jianshu.com/p/7ace3767986ab. 使用BFG移除git库中的大文件或污点提交c. 使用BFG清除git仓库中的隐私文件或大文件d. 为Git仓库瘦身e. git rebase有哪些用法？ 这个可以对项目进行瘦身 可以使用 gitlfs 来迁移仓库的管理方式而瘦身。但是这个会相对麻烦，需要远程仓库也支持。如果是使用gitee或者github等免费远程仓库则需要付费 将二进制或者所有资源文件使用svn进行管理a. 先备份资源文件b. 忽略管理对应资源文件c. 删除资源文件的版本记录d. 同步操作到远程仓库 定期对资源文件的版本记录进行清理","categories":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"},{"name":"资料收集","slug":"经验之谈/资料收集","permalink":"http://yoursite.com/categories/经验之谈/资料收集/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}],"keywords":[{"name":"经验之谈","slug":"经验之谈","permalink":"http://yoursite.com/categories/经验之谈/"},{"name":"资料收集","slug":"经验之谈/资料收集","permalink":"http://yoursite.com/categories/经验之谈/资料收集/"}]},{"title":"我的简历","slug":"my-resume","date":"2020-02-27T11:17:00.000Z","updated":"2020-10-17T06:49:00.939Z","comments":true,"path":"2020/02/27/my-resume/","link":"","permalink":"http://yoursite.com/2020/02/27/my-resume/","excerpt":"","text":"个人信息 简介 赖海潮，男，开始工作时间:2016-10 邮箱 505126057@qq.com 手机 13192294719 个人优势热爱游戏，热爱游戏开发，两年的游戏开发工作经验，参与过多个手机游戏/H5游戏的开发，以及有安卓各个渠道/H5各个渠道/微信小游戏/QQ玩一玩等平台的上线经验，涉及休闲单机和回合联网游戏，勤于积累技术，热衷提高工作效率，心态良好，为人谦虚，学习能力强 期望职位 期望职位 H5游戏开发工程师 薪资要求 17k~22k 行业 游戏 城市 广州 工作经历 广州蜃龙游戏设计有限公司 2018.07-至今 职位:H5游戏前端开发 内容: 2018.07~2019.03 初入公司H53d卡牌游戏开发项目到临危受命，保项目正常开发 刚入公司一个月，依照主程的要求改LayaIDE做了2d地图工具 毛遂自荐，临危受命，主导项目的开发 主程急匆匆走了，我在无法获悉之前项目源码的情况下，根据我之前写的客户端开发框架，以及对前端自动化开发的了解，用了1个月左右的时间搭建了基于laya1.x的开发框架和自动化开发流程。让项目正常进行。 并在接下来的一个月中完善3d开发部分逻辑。 在新的后端入职之后，和其对接完善了网络部分逻辑 完善Laya3d的开发流程 基于nodejs的脚手架功能完善：自动编译，一键打包，一键导表以及导协议数据，3d战斗技能编辑器实现 负责核心回合战斗系统开发和迭代，并参与和辅助新人进行业务功能开发 负责引擎升级到2.0.1和重构优化客户端框架 2019.04~至今 重构h53d卡牌项目的框架，开始新的3dRPG挂机项目，类一刀传世、斗罗大陆 实现了客户端ECS数据驱动的战斗系统框架，高性能，以及方便和后端逻辑共用，提高开发效率 进一步优化自动化开发流程和脚手架工具，提高开发效率 进一步迭代客户端框架：兼容LayaUI和FairyGUI，以便实现在大型项目中，逐步迁移到使用FairyGUI和兼容现有的业务逻辑。 在大型项目中，FairyGUI可以提供更加方便有效的UI组件以及更高的UI迭代效率 学习并实现脱离物理库进行射线检测的方案，减少引擎库包体1.5M左右（对于不需要复杂物理效果需求的大型项目尤为重要） 实现了许多高效有用的复用UI组件，加快项目开发进程。 提出、实现并实践基于MVP业务逻辑架构思想的开发方案 更加明确地确定业务功能的工作量，提高项目进度的确定性 提高业务开发效率，让业务开发与后端尽量解耦，解放前后端 提高业务逻辑的确定性，方便定位错误和修复错误 提高业务功能的可测试性，提高前端独立开发和纠错的效率 缺点：实现业务逻辑会相对繁杂。 工作收获: 一、3dh5卡牌项目 由于项目组中负责前端开发的只有4个人（包括主程），而主程主要向我们讲解项目的架构和负责战斗服务器的联调。在三个入职的新人中，我比较有游戏开发的经验，另外两个是刚接触游戏开发的新人。主程让我负责开发辅助工具，理解架构并且指导新人熟悉项目，指导他们日常中开发遇到的问题。我通过查看游戏引擎的编辑器源码，改写编辑器，开发出我们项目所需的辅助工具。通过结合以往的开发经验以及自己的积累，几天之内就理解了项目的大体架构，并在日常中解答另外两人对项目的疑惑中，掌握更加深。 主程走了之后，由于没能看到项目的全部源码，只理解大体架构的我们没法继续开发下去。而公司又非常看重这个项目，想尽快恢复正常开发。我在和项目负责人和CEO了解了他们对项目的需求后，我毛遂自荐，让我来负责这个项目的重新架构和开发（因为我本身是比较喜欢研究和总结项目架构的，自己也有自己的架构基础）。得到负责人和CEO的肯定后，我在自己原有的2d架构基础上，花了一个星期，完成了适合3d开发的架构，当然也吸收了主程之前的项目的一些好的东西。这套架构，更加解耦，适合多人开发，并且强类型、自动编译（更加高效开发）等等。这个架构也在开发过程中不断迭代优化。通过这次自荐，我的架构思路得到了实践和完善，也学到了许多前端自动化的知识。 使用nodejs开发表格转json工具。由于这是大型游戏开发必须的，而且架构也需要开发过程中有表格数据类型和注释提示。虽然主程之前有留有导表工具，但是由于他的工具没有源码，而且加密的，无法扩展，无法满足开发需求。我通过学习和参考其他转表工具的思路，以及自己研究琢磨。开发出了，可以将表格转成压缩加密的文件，并且导出前端开发所需要的类型和注释文件。这些大大提高了项目的防破解性以及开发的高效性。而且也相应的写了架构中的查表读表工具，进一步提高开发效率。再后来，招到了erlang后端后，我相应的开发了导出后端需要的表格数据文件。这个过程中，我掌握了nodejs的工具开发，也掌握了游戏中的表格数据结构的设计思路。 3d回合的战斗系统的开发，策划想实现基于3d场景的类放置奇兵的回合战斗系统，我通过琢磨3d的动画特效、缓动的实现，以及琢磨放置奇兵的回合机制，很快的实现了战斗系统。至今这个战斗表现也迭代了4次才最终定案。这让没有接触过回合战斗系统开发的我，收获了许多，也学习到了许多关于战斗系统开发的知识。 战斗技能动画机制和快速预览配置工具开发。为了让开发更加纯粹和高效，我开发了完全基于配置的战斗技能动画机制，以及快速预览工具。通过不断的迭代和优化，战斗技能动画机制和工具，能让策划和美术自己去配置动画和预览，无需频繁找我去实现了。 网络模块的探索和开发。由于对于实时性的需求，项目使用了http+websocket的方式进行网络数据传输。erlang后端之前并不熟悉websocket以及erlang对websocket支持不完善，通过查资料和尝试，我和后端一起攻关了网络数据传输。这次让我对erlang更加了解，以及加深了对前端的http以及websocket的理解。 自定义项目发布工具开发。由于Laya引擎工具的局限性以及不完善性，我自己通过学习gulp以及webpack等前端自动化工具，开发了适合项目的发布工具。这样我们的项目发布可定制，可以实现项目发布后的代码压缩和加密混淆的功能，以及项目中的资源文件的版本管理。 二、3dH5 rpg挂机项目 由于这个项目是偏假实时的rpg挂机游戏，在战斗系统开发上，积累了许多适应不同情况的方案，另一方面自己对服务端也有所了解，所以考虑战斗系统实现也会充分考虑后端情况。收获了对挂机类战斗的前后端开发经验和多种有效的实现方案 增长了对大型项目架构和开发经验，并成功实践了自己的架构设计，提高了项目的开发效率。收获设计和落地实践的宝贵经验。 开发过程中接触和闲暇时间的学习，收获了3dwebglshader的开发知识和开发经验，并设想了一套基于Laya的Unityshader转换方案（但未实施） 开发过程中对3d资源的加载优化提出设想，以加快首个场景的加载，以及单个3d模型资源的加载速度，设想和初步实现模型动画片段延迟加载技术（Laya官方是全部动画加载） 由于这个项目是rpg类挂机项目，对物理库的需求不高，但射线检测功能必要，而Laya官方将射线检测和物理库绑定，以至于包体庞大。基于Laya3d实现不需要物理也可以进行射线检测的方案。轻松减少1.5m的包体 在开发完Demo版本之后，业务功能开发工作突增，为了应对项目以后的开发，进行了对项目进行了几乎无痛的架构重构，优化业务逻辑开发流程和方案，优化UI框架支持FairyGUI、兼容LayaUI（以便迁移，减轻前端程序的工作量）。 业绩: 一、3dH5奇幻卡牌项目 一个月完成新的框架开发，让项目进度继续下去 完成了可以展示的demo版本的开发 将项目的引擎版本（Laya1.x）升级到（Laya2.0），并且重构了项目框架 二、3dH5末日风格挂机rpg 提高了项目的开发效率 使得项目架构更加完善和高效、高性能 完成了Demo版本的开发，并成功和合作方签了合同拿到投资，以及更多的其他公司的合作意向 珠海烛墨科技有限公司 2018.03-2018.07 职位:H5游戏前后端开发 工作内容:总的来说： 负责《我要当首富1》&amp;《我要当首富2》的前后端维护、新功能的开发，以及对接微信小游戏，QQ玩一玩平台 公司需要对接各种H5的渠道，也适合刚入职的我去做。技术主管让我去负责对接sdk，学习和了解项目的开发环境和框架。我通过了解框架，熟悉项目的业务逻辑，以及看对接文档，和渠道的技术人员交流，成功地对接完了sdk并上线渠道。通过这些对接sdk的任务，了解和掌握了，不同sdk和渠道之间的兼容，H5游戏 的调试和开发，掌握了之前所不了解的http的基础知识，熟练使用http代理来对线上的项目进行本地调试和开发，以及了解了前后端的登录，支付，等功能开发。 公司的项目用户量大，作弊的玩家总是存在。技术主管让我去了解项目的反作弊机制，修复作弊利用的漏洞。我通过翻看公司的框架源码和反作弊逻辑，修复了几个作弊利用的逻辑漏洞。通过这次的修复作弊漏洞的任务，我了解到了如何反作弊以及处理作弊情况。 公司的项目是H5游戏中的精品，最近微信小游戏开放提审了，我们的项目也需要上线微信小游戏。技术主管，让我升级项目的游戏引擎版本，适配微信小游戏，对接微信小游戏的接口。当时项目的引擎版本为egret4.0.3，与支持微信小游戏的egret版本5.1.6相差太大，项目还有自己实现的自定义资源加载方式，我需要从资源管理模块，项目的构建脚本，项目的配置来进行升级。通过阅读引擎源码，查找资料，成功地将项目引擎版本升级到5.1.6。由于微信小游戏的环境和H5游戏的环境有很大的不同，需要做适配。通过查看游戏引擎源码，以及自个摸索和实践，将新引擎版本的滤镜问题、微信小游戏在iphone中webgl模式拖动闪屏问题解决了。公司的项目的收益来自于支付，所以对接微信小游戏的虚拟支付非常必要。我通过查看对接文档，以及和技术主管讨论前后端支付流程的设计与实现，以必须要保证支付一定要成功为目标，考虑了网络的延迟等问题，实现了前端和后端配合的支付。这次是一个巨大的 任务，让我对egret游戏引擎的实现更加了解，对微信小游戏的对接也更加的有经验，同时对前后端的联合实现更有经验。 公司的项目需要开发新的系统，帮会系统，以促进玩家的留存和金币的消耗，使得游戏更加有兴趣。技术主管，让我尝试去设计这个系统的后端逻辑和后端接口，以及前端的界面逻辑的编写。这对我来说是一个巨大的挑战，我通过自我摸索和请教主管，勉强实现了简陋的后端逻辑。自我摸索以及参考已有代码去编写界面逻辑，实现了系统的界面。这次任务，让我对编写一个严谨简洁的后端逻辑更加有经验，也学习到了如何去设计这样一个后端的接口，了解用egret的纯代码编写界面，让我对界面的代码编辑更加熟练。同时加强了我的前后端的逻辑思维，更加了解前后端的配合。 公司的旧项目需要上线QQ玩一玩，抓住手机QQ的流量红利。我需要去将项目的引擎升级，以及修复发布到QQ玩一玩出现的bug，对接玩一玩平台的能力（分享，支付），服务端需要写对应QQ玩一玩能力的处理逻辑。 工作业绩: 能快速上手项目的渠道对接，帮助公司开启新的盈利渠道，并维护已接渠道的维护 升级了公司项目所用的引擎版本，并对接和适配微信小游戏平台，让公司能抓住微信小游戏带来的新机会和巨大的用户量 参与开发了商会系统的前后端，为旧的项目带来了新的活力，提高了游戏的留存和用户粘性。 参与维护两个旧项目的，维持线上项目的稳定 珠海文景科技有限公司 2018.02-2018.03职位:COCOS2DX前端开发 工作内容: 刚入职时，由于我对Cocos2dx-lua以及公司的项目开发所需要的基础知识不完备，所以我需要在短时间内去掌握这些基础知识，技术主管通过介绍书籍，安排学习任务，手把手教导我解决问题，我在一个星期内通过不断地学习和实践，掌握了Cocos2dx-lua这个引擎的基础、lua脚本语言的基础、Objective-c语言基础、CocosBuilder、XCODE、CocosIDE等，然后能运用这些基础进行入门项目的开发、简单的自动化lua脚本的开发、异常上报模块的对接与开发。这段时间的学习让我的能力更强，基础知识更加全面，学习能力也得到了加强。在掌握基础知识后，技术主管给我分配一些简单的任务。如：写lua自动化工具，批量替换icon 公司的项目使用了自己实现加密的sqlite库，但是在使用的时候，可能会和原生的没有实现加密的sqlite库有冲突，这些没加密的sqlite库在接入第三方sdk时会用到。技术主管让我去研究sqlite的源码，解决这个问题。我通过上网查阅资料、查看sqlite的源码，找到了sqlite实现加密的方式，然后想出了，通过区分加密和原生的sqlite来解决冲突。这次的任务完成，让我对sqlite和游戏数据加密有更深的理解。 当时的项目需要实现资源加载的断点续传，技术主管让我去研究如何实现在项目的资源管理模块AssetsManager的基础上如何实现断点续传。于是，我通关研究Cocos2dx的AssetsManager的源码，了解和掌握资源加载的逻辑，然后去网上找资料，研究断点续传的原理和实现，最后通过摸索和实践，在项目的资源管理模块的基础上实现了断点续传。 由于业务需要，公司需要有自己的统计上报，于是让我去了解和研究adjust这个统计上报服务，由于我对于运营的专业术语并不熟悉，adjust中的文档看起来非常吃力，但是通过查找资料，对接实践，让我逐渐了解了adjust的功能和特性，并把sdk对接到项目中。这次任务，让我了解更多统计上报的知识，以及运营相关的术语。 由于公司的游戏将要在国内发行，应渠道商的要求，我们需要对接各个安卓渠道的sdk。技术主管让我去研究一下QuickSdk的对接。我通过查看对接文档，查找资料解决对接过程中的问题，把Sdk对接到游戏的Android和IOS项目中去。这次对接，让我对于Cocos2dx对接渠道，有了更多的经验，也有了使用QuickSDK的经验。 工作业绩: 学习使用sqlite以及解决封装加密的sqlite与第三方sdk要求引入的SQLite库的冲突问题 研究底层AssetsManager实现断点续传 珠海逗你玩科技有限公司 2016.10-2018.01 职位:前后端技术开发工作内容:1.负责使用Cocoscreator、Layabox等H5游戏引擎进行单机和联网游戏的前端开发2.负责对接安卓端的SDK的对接和维护，还有安卓apk开发3.负责简单的游戏后台开发，和游戏后台维护4.负责新人进来的培训和项目管理，主要内容是Layabox和CocosCreator的游戏前端开发5.入职前曾经学过一段时间的unity前端开发，入职后也一直对unity开发感兴趣，也一直有了解 工作业绩: 开发了公司第一款上线的休闲游戏《十万个没想到》（用Cocos creator（以下简称cc）开发，在安卓和iOS上线），对休闲游戏的开发流程更加了解，也掌握了使用cc进行休闲游戏的开发，以及一些简单性能优化 帮技术老大对接安卓的游戏渠道，掌握了cc的安卓版发布，以及游戏渠道对接流程，更加了解安卓开发 帮公司开发了一个地图定位蓝牙防丢器的安卓应用，了解在第三方地图定位，蓝牙开发，相机开发等安卓开发知识 用cc帮公司开发了一个H5的微信宣传小游戏，了解了微信jssdk的对接，以及使用http和服务器交互 用cc帮公司开发了一款名为《推坨子》的麻将比大小棋牌游戏，掌握了简单的棋牌开发，以及使用pomelo进行简单的服务器开发(最后没能上线) laya 项目经历 末日 2019.03-至今 项目角色: H5游戏前端主程 项目链接: 游戏暂未上线，正在开发中 项目描述: 3dh5末日风格挂机rpg 由于这个项目是偏假实时的rpg挂机游戏，在战斗系统开发上，积累了许多适应不同情况的方案，另一方面自己对服务端也有所了解，所以考虑战斗系统实现也会充分考虑后端情况。收获了对挂机类战斗的前后端开发经验和多种有效的实现方案 增长了对大型项目架构和开发经验，并成功实践了自己的架构设计，提高了项目的开发效率。收获设计和落地实践的宝贵经验。 开发过程中接触和闲暇时间的学习，收获了3dwebglshader的开发知识和开发经验，并设想了一套基于Laya的Unityshader转换方案（但未实施） 开发过程中对3d资源的加载优化提出设想，以加快首个场景的加载，以及单个3d模型资源的加载速度，设想和初步实现模型动画片段延迟加载技术（Laya官方是全部动画加载） 由于这个项目是rpg类挂机项目，对物理库的需求不高，但射线检测功能必要，而Laya官方将射线检测和物理库绑定，以至于包体庞大。基于Laya3d实现不需要物理也可以进行射线检测的方案。轻松减少1.5m的包体 在开发完Demo版本之后，业务功能开发工作突增，为了应对项目以后的开发，进行了对项目进行了几乎无痛的架构重构，优化业务逻辑开发流程和方案，优化UI框架支持FairyGUI、兼容LayaUI（以便迁移，减轻前端程序的工作量）。 项目业绩: 提高了项目的开发效率 使得项目架构更加完善和高效、高性能 完成了Demo版本的开发，并成功和合作方签了合同拿到投资，以及更多的其他公司的合作意向 英灵战歌 2018.07-2019.3 项目角色: H5游戏前端开发 项目链接: 项目未上线 项目描述: 项目简介: 3d h5 卡牌游戏，爽快战斗，精美的3d美术 人员分工: 3个前端，一个后端，策划部门，美术部门 我的责任: 前端架构设计和迭代优化； 核心战斗系统开发、迭代优化； 业务功能开发； 新人培训； 自动化脚手架开发，编辑器开发，工具开发； 项目业绩: 项目收益：暂无收益 我的贡献：独立设计和实现了游戏的前端架构，设计和实现了核心的战斗系统并迭代优化多次，开发战斗编辑器、开发自动化脚手架、开发导表工具；培训了两个新人上手项目开发 我的收获： 全程负责项目的架构和优化、以及具体的战斗和业务开发，让我收获了项目的架构和优化经验； 开发提高效率的编辑器、脚手架、导表工具，让我收获了开发工具的经验，提高了编程能力 我要当首富1&amp;2 2017-至今 项目角色:前后端开发工程师 项目链接:https://www.feihuo.com/game/index/slug/h5wydsf2 项目描述 项目概况：项目在各大H5游戏平台上线，盈利 人员分工：3个人负责前后端业务功能的维护和开发，两个美术 我的责任：我负责旧项目（我要当首富1）的维护、新渠道的对接，后期负责新旧项目的新功能（商会）的开发（主要负责前端）以及负责项目适配微信小游戏和QQ玩一玩平台，帮合作渠道解决他们的安卓apk的问题（我略懂安卓原生开发） 项目业绩 开发和上线了商会功能，进一步提高了游戏社交力，以及增加用户粘性 适配了微信小游戏平台以及QQ玩一玩平台，让项目有新的增加点 对接了两个H5渠道，增加项目的盈利来源 战争与魔法 2015-至今 项目角色: Cocos2dx前端开发 项目链接: Taptap: https://www.taptap.com/app/56021/topic 官网：http://www.warandmagicgame.com/ 项目描述: 项目概况：外服上线盈利已久，正准备在国服推广 人员分工： 前端开发部门、后端开发部门、美术部门、测试部门 我的责任： 学习Cocos2dx-lua和OC苹果开发，熟悉项目框架，学习使用lua开发工具； 开发练手项目； 对接QuickSDK； 研究底层热更功能； 研究断点续传功能； 研究自定义修改的加密的sqlite和ios内置的sqllite的冲突问题，并解决； 开发业务功能 项目业绩 完成了底层热更和断点续传功能 开发了小部分业务功能 初步对接了QuickSDK 解决了自定义修改的加密的sqlite和ios内置的sqlite冲突问题 十万个没想到 2016.10-2017.03 项目角色： 主程兼策划 项目链接：http://news.4399.com/swgmxd/ 项目描述 项目的概况： 使用CocosCreator 进行开发的休闲手机单机游戏，在安卓多个渠道以及IOSAppStore发布 人员分工：1个程序，5个美工，关卡策划是大家一起策划，3个运营 我的职责： 负责游戏主程序的开发 安卓版本的发布和适配 安卓渠道sdk对接 后续三个游戏（分别是《十万个没想到》、《疯狂老司机》、《超级三角形》）的安卓版本维护至今 项目业绩 项目收益：收益微薄 我的贡献： 尽我所能去对接安卓渠道，以及公司的游戏的安卓版本的维护：后续渠道反馈的问题修复-&gt;重新打包上线 我的收获： 对游戏开发流程（立项-&gt;策划-&gt;开发-&gt;渠道对接-&gt;上线-&gt;后期维护）更加熟悉和了解 对CocosCreaor开发更加了解和熟悉，游戏开发能力得到了提升 对安卓开发有所了解 Fancytower单机版 2017.12 - 2018.1 项目角色： 主程兼策划 项目链接：http://aigamehome.gitee.io/fancytowerclient/build/web-mobile/ 项目描述 项目简介: 休闲物理小游戏 项目概况:正在开发中，已经开发了半个月，是公司内部的gamejam比赛的第一名，用cocoscreator1.8开发 人员分工:两个美术，两个程序 我的职责:负责客户端重构以及联网版的服务端编写（使用node+pomelo） 收获 我的收获:对cocoscreator更加了解，有了客户端模块化架构设计的经验，能够独立进行简单的游戏服务器搭建 西游战姬H5 2017.09 - 2017.12 项目角色： UI程序员 项目链接： 项目描述 项目概况：项目封存中 人员分工:有大约5~6个程序 我的责任:负责部分界面功能逻辑的编写 收获 项目收益：暂无 我的贡献:两个月从基础开始完成了6个界面功能的开发 我的收获:了解了LayaBox大型项目的开发流程 掌握了Layabox的基础使用 研究过这个项目的前后端架构，部分功能模块的实现 推坨子 2017.05-2017.07 项目角色： 游戏前端程序员 项目链接：无 项目描述 项目概况：IOS和安卓上线了，H5的封存了 人员分工：两个美术，两个Unity程序，一个CocosCreator程序 我的责任：负责使用CocosCreator进行H5端的开发 项目业绩 项目收益：属于地方棋牌，收益不知 我的贡献：完成了H5端的架构搭建和主要功能开发 我的收获： 用CocosCreator开发简单的棋牌 了解联网游戏的开发流程 世邦家居5号馆开业H5宣传小游戏 2017.04-2017.06 项目角色： 主程兼策划 项目链接：无 项目描述 项目概况：使用CocosCreator开发的已经上线服务完的H5宣传小游戏，为了积累人气 人员分工：一个客户端程序，一个服务端程序，一个美工 我的职责： 负责客户端的开发 对接微信jssdk 测试 项目业绩: 项目收益：不知 我的贡献：开发了客户端程序并对接微信jssdk还有测试 我的收获： 了解并学习了H5游戏对接微信jssdk的流程 更加熟悉Cocoscreator的开发 了解并学习了H5游戏和服务器对接 时光情书demo 2017.09 - 2017.12 项目角色： 主程 项目链接：http://aigamestudio.ailhc.gitee.io/time_love_letter/build/web-mobile/ 项目描述 项目概况：用cocoscreator开发的公司内部的gamejam项目，用时一个星期 人员分工:一个程序，一个美术，两个策划 我的责任:主导游戏的设计和开发 收获 项目收益：暂无 我的收获:更加了解模块化开发，设计了自己的基于Cocoscreator的事件机制模块 教育经历大学 广东科学技术职业学院 大专 2015-2018 游戏软件专业 学校经历 担任班里的心理委员 担任院学习部的干事，学习策划和组织校内活动，锻炼策划、组织和团队协作能力 学习成绩优秀，拿过两次国家励志奖学金 大一学过一年的Unity，做过些练手的demo 大二进入创业公司逗你玩科技有限公司，做游戏开发，开发并上线了自己的第一款手机游戏《十万个没想到》高中 茂名市第一中学 2012-2015 社交 github https://github.com/AILHC 微博","categories":[{"name":"关于作者","slug":"关于作者","permalink":"http://yoursite.com/categories/关于作者/"}],"tags":[{"name":"关于作者","slug":"关于作者","permalink":"http://yoursite.com/tags/关于作者/"}],"keywords":[{"name":"关于作者","slug":"关于作者","permalink":"http://yoursite.com/categories/关于作者/"}]}]}